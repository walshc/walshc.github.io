[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programming and Quantitative Skills for IBA - R",
    "section": "",
    "text": "1 About\n  \nWelcome to the online “book” for the R part of the first-year IBA course Programming and Quantitative Skills. This book accompanies the content covered in the lectures. In the lectures, I will follow the material in the lecture slides, and this material is discussed in greater depth in this online book. On Canvas, I will post which chapters/slides we will cover in each lecture.\nAs this book is new, it is likely that it will be edited throughout the semester."
  },
  {
    "objectID": "getting-started.html#what-is-r-and-what-is-rstudio",
    "href": "getting-started.html#what-is-r-and-what-is-rstudio",
    "title": "2  Getting Started",
    "section": "2.1 What is R and what is RStudio?",
    "text": "2.1 What is R and what is RStudio?\nR is a programming language which specializes in statistical computing and graphics.\nRStudio, on the other hand, is a desktop application where you can write R code, execute R programs, and view plots created by R.\nThus R is the programming language itself, and RStudio is the desktop application you will use to write and execute R code.\n\n2.1.1 What is a programming language?\nWithout getting into a complicated details, a programming language is a way to communicate to a computer via written text in a way that the computer can understand so that you can instruct it to do various operations for you. This is very different to how we often usually interact with a computer, which often involves pointing and clicking on different buttons and menus with your mouse.\nKnowing how to program is a very useful skill because you can automate repetitive tasks that would take you a very long time if you had to them “by hand” (i.e. by clicking things with your mouse). For example, suppose you work in a hotel in a city and you need to check how much your competitors are charging for rooms on different days so that you can adjust prices to stay competitive. Every day you have to go to all the different websites of the competing hotels and take note of the prices in an Excel sheet. With programming, what you could do instead is write code that tell the computer to automatically visit those websites every day, record the hotel room prices, and put them in an Excel sheet for you. This is a process called web scraping. This is just one example of the many ways programming languages can automate repetitive tasks.\nWhen humans speak to each other and someone makes a grammar mistake, it usually isn’t a big deal. We usually know what they mean. But if you make a “syntax” mistake in a programming language, it won’t understand what you mean. The computer will either throw and error or, worse still, do something you didn’t want it to do. Therefore we need to be very careful when writing in a programming language.\n\n\n2.1.2 Why learn R?\nThere are many different programming languages out there, and each have their different strengths and weaknesses. R is specialized in working with datasets, performing statistical analysis and visualizing data. These will be very useful for later courses in the IBA program, and for many different jobs you might have in the future after your studies.\nR has many advantages over alternatives:\n\nR is free, open source and runs on all common operating systems. This means you can share your code with anyone and they will be able to run it, no matter what computer they are on or where they are in the world.\nThere is a very large active community that creates packages to do a wide-range of operations, keeping R up to date with the latest developments. Excellent community help is also available at Stackoverflow.\nThe R language is easier to learn than some similar alternatives. Programming languages also have a lot in common, so if you learn one it’s much easier to learn another one. With some R knowledge, it makes learning other languages, such as Python or Julia, much easier.\nRStudio is a great free integrated desktop environment to write and run R code.\nR is also extremely versatile in what it can do. For example, this online “book” and the accompanying slides were made entirely in RStudio!\n\nIn the second year of the IBA program you will take Statistics 2. There we will learn how to estimate statistical models using R. You can therefore also think of this course as a foundation providing the background programming knowledge for that course. Thus your journey with R won’t end after you take the exam for this course. You will use it again and again throughout your studies!\nMore recently, employers are increasingly looking for people with programming skills. Knowledge of R is therefore a great addition to your CV when you look for a job after your studies!"
  },
  {
    "objectID": "getting-started.html#installing-r-and-rstudio",
    "href": "getting-started.html#installing-r-and-rstudio",
    "title": "2  Getting Started",
    "section": "2.2 Installing R and RStudio",
    "text": "2.2 Installing R and RStudio\nTo get started, we need to install both R and RStudio. Install R first, then RStudio:\n\nTo download and install R, go here.\nTo download and install RStudio, go here.\n\nIf you are on a university computer, R and RStudio will already be installed.\nBelow are OS-specific instructions.\n\n2.2.1 Installation on Windows\n\nGo here, click on “Download R for Windows” and then click on the link for “base”. Then click on “Download R-X.Y.Z for Windows”, where X.Y.Z is the latest version number. Click on the downloaded .exe file and follow the installation steps.\nGo here and download the .exe file listed next to the Windows OS. Click on the downloaded .exe file and follow the installation steps.\n\nOn Canvas you will find a video demonstration of me installing both R and RStudio on Windows.\n\n\n2.2.2 Installation on MacOS\n\nGo here, click on “Download R for macOS”. If you have a newer Mac with an M1 or M2 processor, download the .pkg file with “arm64” in the name. For older Macs, download the “x86_64” one. Click on the file and follow the installation steps.\nGo here and download the .dmg file listed next to macOS. Click on the downloaded .dmg file and copy it to your applications.\n\nIf you have difficulties, there are many videos on YouTube demonstrating the installation of R and RStudio on a Mac.\n\n\n2.2.3 Installation on Ubuntu/Debian\n\nTo install R, run the following command in the command line: sudo apt install r-base.\nTo install RStudio, first download the .deb file from the RStudio website. Then in the command line, change to the directory containing the file and install it with sudo dpkg -i rstudio-*.deb."
  },
  {
    "objectID": "getting-started.html#opening-rstudio",
    "href": "getting-started.html#opening-rstudio",
    "title": "2  Getting Started",
    "section": "2.3 Opening RStudio",
    "text": "2.3 Opening RStudio\nAfter the installation, try opening RStudio on your computer. If prompted to choose a version of R, just choose the default option. After opening RStudio you should see something like:\n What we will do in the next chapter is learn some basic commands in R."
  },
  {
    "objectID": "r-as-a-calculator.html#the-r-console",
    "href": "r-as-a-calculator.html#the-r-console",
    "title": "3  R as a Calculator",
    "section": "3.1 The R Console",
    "text": "3.1 The R Console\nThe R console is where you provide commands in the R programming language to be executed by the computer. It is possible to access the R console without RStudio using a very basic command-line interface that looks like this:1\n\n\n\nR Terminal\n\n\nBut RStudio also has this R console, as well as many other useful features. Therefore we will stick to using RStudio for the rest of this course.\nIf we want to calculate 2+3, we simply go to the Console tab in RStudio and type 2+3, just like in the screenshot below:\n\nWe then press Enter to see the answer. What we see then is R giving the following output:\n\nThe [1] before the 5 here essentially means the 5 is the first number in the output. This is obvious here, but this feature will be more useful later when we do operations on more numbers. But for now, we can just ignore the [1].\nIn this book, I won’t always show screenshots like this. Instead I will show code snippets in boxes like this:\n\n2 + 3\n\n[1] 5\n\n\nThe part that is code will be in color and the output will be in a separate gray box below it. In these code boxes there is a small clipboard icon on the right which you can use to copy the code to be able to experiment with it in RStudio yourself.\nWe will now go through some different operations. We will also learn about functions and their arguments along the way, which we will be be using again and again throughout the rest of this course."
  },
  {
    "objectID": "r-as-a-calculator.html#addition-subtraction-multiplication-and-division",
    "href": "r-as-a-calculator.html#addition-subtraction-multiplication-and-division",
    "title": "3  R as a Calculator",
    "section": "3.2 Addition, Subtraction, Multiplication and Division",
    "text": "3.2 Addition, Subtraction, Multiplication and Division\nThese are given by the standard +, -, * and / operators that you would use in other programs like Excel, or even in an internet search engine. For example:\n\n2 + 3\n\n[1] 5\n\n5 - 3\n\n[1] 2\n\n2 * 3\n\n[1] 6\n\n3 / 2\n\n[1] 1.5\n\n\nIt is also possible to do multiple operations at the same time using parentheses. For example, suppose we wanted to calculate: \n\\frac{2+4}{4\\times 2} = \\frac{6}{8} = 0.75\n We can calculate this in R as follows:\n\n(2 + 4) / (4 * 2)\n\n[1] 0.75"
  },
  {
    "objectID": "r-as-a-calculator.html#troubleshooting-escaping-in-r",
    "href": "r-as-a-calculator.html#troubleshooting-escaping-in-r",
    "title": "3  R as a Calculator",
    "section": "3.3 Troubleshooting: “Escaping” in R",
    "text": "3.3 Troubleshooting: “Escaping” in R\nSuppose by accident you left out the closing parentheses and you see the following:\n\n\n&gt; (2 + 4) / (4 * 2\n+\n\n\nR didn’t run the command, but it also didn’t give an Error. What happened is that Enter moved to a new line instead of executing the command. To “Escape” this situation, you just need to press the Esc button. In general, if anything strange happens in R and you get stuck, you can always press the Esc button to return to “normal”."
  },
  {
    "objectID": "r-as-a-calculator.html#exponentiation-taking-powers-of-numbers",
    "href": "r-as-a-calculator.html#exponentiation-taking-powers-of-numbers",
    "title": "3  R as a Calculator",
    "section": "3.4 Exponentiation (Taking Powers of Numbers)",
    "text": "3.4 Exponentiation (Taking Powers of Numbers)\nx^n multiplies x by itself n times. For example, 2^3=2\\times 2\\times 2 = 8. In R we use the ^ operator to do this:\n\n2^3\n\n[1] 8"
  },
  {
    "objectID": "r-as-a-calculator.html#absolute-value",
    "href": "r-as-a-calculator.html#absolute-value",
    "title": "3  R as a Calculator",
    "section": "3.5 Absolute value",
    "text": "3.5 Absolute value\nTaking the absolute value turns a negative number into the same number without a minus sign. It has no effect on positive numbers.\nIn mathematics notation we write |x| for the absolute value of x. The formal definition is:\n\n|x| = \\begin{cases} x & \\text{ if } x \\geq 0 \\\\ -x & \\text{ otherwise}\n\\end{cases}\n\nHere are some examples:\n\n|-2|=2\n|3|=3.\n\nThis is what the function looks like when we plot it for different x:\n\n\nShow code generating the plot below\nif (!require(ggplot2)) install.packages(\"ggplot2\")\nlibrary(ggplot2)\nx &lt;- seq(-2, 2, length.out = 1000)\nggplot(data.frame(x, y = abs(x)), aes(x, y)) +\n  geom_line() +\n  ylab(\"abs(x)\")\n\n\n\n\n\nWe’ll learn how to make plots like this later in Chapter 16.\nIn R we can calculate these with:\n\nabs(-2)\n\n[1] 2\n\nabs(3)\n\n[1] 3\n\n\nTaking the absolute value in R involves using what is called a function. Functions are used by calling their names and giving the arguments to the function in parentheses. When we do abs(-2), abs is the name of the function and -2 is the argument.\nIn many ways the functions in R work a lot like the functions in Excel, just they might have different names or be used a bit differently. For example, in Excel you write =ABS(-2) to take the absolute value of -2. The argument is the same, and the function name only differs in that in Excel you need to use capital letters whereas in R you use lowercase letters (in addition, Excel requires you to put an = before the function name).\nWhen using functions it is helpful to read their help pages. You can look at this by typing help(abs) or ?abs in the Console pressing Enter. The help page then pops up in the Help tab, like in the screenshot below:\n\n\n\nHelp Page for abs\n\n\nWe can see that it says abs(x) computes the absolute value of x. So we are told that x is the argument.\nWe will be using many different functions and it’s a good habit of to look at their help pages. The help pages will be available to you in the Exam."
  },
  {
    "objectID": "r-as-a-calculator.html#square-and-cubed-roots",
    "href": "r-as-a-calculator.html#square-and-cubed-roots",
    "title": "3  R as a Calculator",
    "section": "3.6 Square and Cubed Roots",
    "text": "3.6 Square and Cubed Roots\nThe square root of a number x is the y that solves y^2=x. For example, if x=4, both y=-2 and y=2 solve this. The principal square root is the positive y from this.\nHere is what the square root function looks like for different x:\n\n\nShow code generating the plot below\nif (!require(ggplot2)) install.packages(\"ggplot2\")\nlibrary(ggplot2)\nx &lt;- seq(0, 10, length.out = 1000)\nggplot(data.frame(x, y = sqrt(x)), aes(x, y)) +\n  geom_line() +\n  ylab(\"sqrt(x)\")\n\n\n\n\n\nWe take the principal square root in R using the sqrt() function:\n\nsqrt(9)\n\n[1] 3\n\n\nIt is also possible to take a square root by exponentiating a number by \\frac{1}{2}:\n\n9^(1/2)\n\n[1] 3\n\n\nWith this approach we can also take the cubed root of a number: \\sqrt[3]{8}=8^\\frac{1}{3}=2:\n\n8^(1/3)\n\n[1] 2"
  },
  {
    "objectID": "r-as-a-calculator.html#exponentials",
    "href": "r-as-a-calculator.html#exponentials",
    "title": "3  R as a Calculator",
    "section": "3.7 Exponentials",
    "text": "3.7 Exponentials\nA very important function in mathematics and statistics is the exponential function. The definition of \\exp\\left(x\\right), or e^x, is given by: \ne^x = \\underset{n\\rightarrow \\infty}{\\lim} \\left(1 + \\frac{x}{n}\\right)^n\n\nNote: you don’t need to know or remember this definition for the exam. You only need to know how to use the exponential function in R.\nThis is what the function looks like:\n\n\nShow code generating the plot below\nif (!require(ggplot2)) install.packages(\"ggplot2\")\nlibrary(ggplot2)\nx &lt;- seq(-2, 2, length.out = 1000)\nggplot(data.frame(x, y = exp(x)), aes(x, y)) +\n  geom_line() +\n  ylab(\"exp(x)\")\n\n\n\n\n\nIn R we can use the exp() function to calculate the exponential of any number:\n\nexp(1)\n\n[1] 2.718282"
  },
  {
    "objectID": "r-as-a-calculator.html#logarithms",
    "href": "r-as-a-calculator.html#logarithms",
    "title": "3  R as a Calculator",
    "section": "3.8 Logarithms",
    "text": "3.8 Logarithms\nAnother common mathematical function is the logarithm, which is like the reverse of exponentiation.\nThe log of a number x to a base b, denoted \\log_b\\left(x\\right), is the number of times we need to multiply b by itself to get x. For example, \\log_{10}\\left(100\\right) = 2, because 10\\times 10=100. We need to multiply the base b=10 by itself twice to get to x=100.\nA special logarithm is the natural logarithm, \\log_e(x), which is the logarithm to the base \\exp(1)=e^1\\approx 2.7183. This is also written as \\ln(x).\nThis is what the function looks like:\n\n\nShow code generating the plot below\nif (!require(ggplot2)) install.packages(\"ggplot2\")\nlibrary(ggplot2)\nx &lt;- seq(0.01, 10, length.out = 1000)\nggplot(data.frame(x, y = log(x)), aes(x, y)) +\n  geom_line() +\n  ylab(\"ln(x)\")\n\n\n\n\n\nIn R we use the log() function to calculate the natural logarithm:\n\nlog(1)\n\n[1] 0\n\n\nWhat if we want to calculate the logarithm to a base other than e? If we look at the help page for log() using help(log) or ?log we can see that the log function has 2 arguments:\n\nx: the number we want to take the log of.\nbase: “the base with respect to which the logarithms are computed. Defaults to e=exp(1)”.\n\nThis is the first time that we have seen a function with more than one argument. Earlier when we used the log() function to calculate the natural logarithm we only used one argument because we used the default setting for the base. But when we want to use a base other than e, we need to specify it.\nHow we calculate \\log_{10}\\left(100\\right) in R is as follows:\n\nlog(100, base = 10)\n\n[1] 2\n\n\nWe write both arguments into the log() function, separated by commas.\nThis is just like how we used functions with more than one argument in Excel, for example the VLOOKUP function. We separated the arguments there by commas as well."
  },
  {
    "objectID": "r-as-a-calculator.html#footnotes",
    "href": "r-as-a-calculator.html#footnotes",
    "title": "3  R as a Calculator",
    "section": "",
    "text": "On Windows you can access this by going to C:\\Program Files\\R\\R-4.3.1\\bin and running the file R.exe. On Mac or Linux you can go to the terminal and type R and Enter.↩︎"
  },
  {
    "objectID": "data-types.html#the-assignment-operator",
    "href": "data-types.html#the-assignment-operator",
    "title": "4  Objects and Object Types",
    "section": "4.1 The Assignment Operator",
    "text": "4.1 The Assignment Operator\n\n4.1.1 Assigning Objects\nIn the previous chapter when we were using R as a calculator, we simply typed the numbers we wanted to add if we wanted to add them, like 2 + 3. We can also store numbers in R as objects. We do this using the assignment operator &lt;-, which is a “less than symbol” and a “minus” symbol next to each other.\nFor example, let’s assign the value 2 to an object called a and the value 3 to an object called b:\n\na &lt;- 2\nb &lt;- 3\n\nThe &lt;- operator assigns the value 2 to a, and similarly for b.\nBecause we use the assignment operator &lt;- so often, RStudio has a shortcut for it. If you hold Alt and press -, RStudio will write &lt;-, including spaces around it. It makes the spaces because a &lt;- 2 is easier to read than a&lt;-2.\n\n\n4.1.2 The Environment Tab in RStudio\nWhen we do this, we see values a=2 and b=3 in the Environment tab in RStudio, just like in the screenshot below:\n\nWe can now perform all the operations we learned about using a and b instead of the numbers. For example:\n\na + b\n\n[1] 5\n\na / b\n\n[1] 0.6666667\n\n\n\n\n4.1.3 Troubleshooting with the Assignment Operator\nAlthough you can assign 2 to a with either a &lt;- 2 or a&lt;-2, it is very important that you don’t have a space in between the &lt; and the - in the assignment operator. If you try to instead do a &lt; - 2, R will check if a is less than -2, instead of assigning 2 to a. If a is not stored in the Environment you will get an error that says Error: object 'a' not found. This is another reason why need to be very careful when typing our code! It’s a good idea therefore to use the Alt+- shortcut to make &lt;-.\nIt is also possible to use the = sign for assignment instead of &lt;-. For example, it’s possible to do a = 2 instead. I will use &lt;- in this course as it is the recommended approach in R style guides, but you are free to use = instead in the exam and assignments if you prefer."
  },
  {
    "objectID": "data-types.html#common-object-types",
    "href": "data-types.html#common-object-types",
    "title": "4  Objects and Object Types",
    "section": "4.2 Common Object Types",
    "text": "4.2 Common Object Types\nWe now go through some different object types.\n\n4.2.1 Numeric Vectors\nIn R we often work with vectors, which are collections of values of the same type. You can think of these as a column of data in an Excel file. If we want to store the vector of numbers a=\\begin{pmatrix}1 \\\\ 3 \\\\ 7 \\\\ 2\\end{pmatrix} in R we can use the c() function, where “c” stands for combine. We put each element of the vector in c() separated by commas:\n\na &lt;- c(1, 3, 7, 2)\n\nNotice in the Environment tab that now we have overwritten the a &lt;- 2 that we had before. We can see that a is now a num [1:4]: it’s a numeric vector with 4 elements.1\nOne thing worth mentioning is that when we store single numbers, such as with b &lt;- 3, we are actually creating a numeric vector with only 1 element (instead of 4 like in the example above). We could create an identical object with b &lt;- c(3) instead.\n\n\n4.2.2 Logical Vectors\nOften we have data on a variable where the answers are “Yes” or “No”. We often code these as a logical vector which is binary: the elements are either TRUE (corresponding to “Yes”) or FALSE (corresponding to “No”). For example:\n\na &lt;- c(TRUE, FALSE, TRUE, TRUE)\n\nWe can see in the Environment tab that a is now a logi [1:4]: it’s a logical vector with 4 elements. It’s possible to convert logical vectors into numeric ones with 1s replacing the TRUEs and 0s replacing the FALSEs. We can do this with the as.numeric() function:\n\nas.numeric(a)\n\n[1] 1 0 1 1\n\n\n\n\n4.2.3 Character Vectors\nR can also work with character vectors which are vectors composed of letters or words instead of numbers or logical constants (TRUE or FALSE). We have to write the words in quotes, otherwise R will think we providing it with variable names instead:\n\na &lt;- c(\"programming\", \"and\", \"quantitative\", \"skills\")\n\n\n\n4.2.4 Factors (Categorical Variables)\nSurveys often contain questions with multiple possible responses. For example, imagine a survey which asked people how long it took them to travel to campus and what mode of transportation they used, with the options being:\n\nTrain\nWalk\nCycle\n\nSuppose we have 6 responses for this survey and we coded the times (in minutes) as a numeric vector time and the travel modes as a character vector travel_mode:\n\ntime &lt;- c(25, 20, 15, 10, 17, 30)\ntravel_mode &lt;- c(\"train\", \"train\", \"walk\", \"cycle\", \"walk\", \"train\")\n\nBecause categorical variables like travel_mode are so common, R has a special object type for them called factors. We can turn any vector into a factor using the factor() function:\n\ntravel_mode &lt;- factor(travel_mode)\ntravel_mode\n\n[1] train train walk  cycle walk  train\nLevels: cycle train walk\n\n\nWe can see in the Environment that we have a factor with 3 levels, \"cycle\", \"train\", \"walk\". The levels are all of the different categories.\nHaving a variable in this format will be very useful when we learn how to visualize data. They will also become very useful when we estimate statistical models with categorical data in Statistics 2 next year.\n\n\n4.2.5 Data Frame\nAn object that we will use very frequently is the data.frame. This is a rectangular object with different columns representing different variables and rows representing different observations. For example, we could collect the 6 survey respondents about their commute into a data.frame as follows:\n\ndf &lt;- data.frame(travel_mode, time)\ndf\n\n  travel_mode time\n1       train   25\n2       train   20\n3        walk   15\n4       cycle   10\n5        walk   17\n6       train   30\n\n\nThe variable names are listed on top with the values underneath. On the side we can see the numbers 1 to 6, which index the rows of the data.frame.\nWe can also view the data.frame in RStudio by clicking on df in the Environment tab. You could also open this by typing View(df) in the console. The first row means that the first respondent took the train and it took 25 minutes. The second row means that the second respondent also took the train and it took 20 minutes.\n\n\n\nViewing a dataframe in RStudio\n\n\nWhen variables are organized in a data.frame, it becomes very easy to summarize the data and make visualizations with them. We will learn how to do this in the upcoming chapters.\n\n\n4.2.6 Lists\nA data.frame is actually a special type of list, which is another object type. While all elements of a vector (created with the c() function) must have the same type (numeric, logical or factor), a list can have elements of any type, and also any length.\nHere is an example of a list:\n\nmy_list &lt;- list(x = 1:3, y = TRUE, z = c(\"a\", \"b\"))\n\nIt has elements that are numeric, logical and character vectors, and the elements all have different lengths (3, 1 and 2).\nA data.frame can have elements/columns of different types (such as in the travel mode example above, which had numeric and factor variables), but all elements/columns data.frame must have the same length (unlike a list where any length is possible)."
  },
  {
    "objectID": "data-types.html#footnotes",
    "href": "data-types.html#footnotes",
    "title": "4  Objects and Object Types",
    "section": "",
    "text": "This is not relevant for the exam, but strictly speaking R has two numeric vector types: integer vectors and double vectors. An integer vector can only contain whole numbers (like -3 and 2), whereas a double vector can contain non-whole numbers (like -4.5 and 1.25). When we create the vector in the example with a &lt;- c(1, 3, 7, 2) it actually creates a double vector. To specify it to be an integer vector we can write an L after the numbers: a &lt;- c(1L, 3L, 7L, 2L). We can also convert the vector to integer with the as.integer() command, like: a &lt;- as.integer(c(1, 3, 7, 2)). Why are non-whole numbers called double vectors? The “double” in the name for double vectors refers to the amount of precision with which R actually uses with numbers. What do we mean by precision? When R stores the number \\frac{1}{3}, it doesn’t store it with an infinite number of 3s after the decimal (as your computer would run out of memory). R instead stores only a certain number of significant digits, up to 56 bytes. If we run the command sprintf(\"%0.25f\", 1/3), which prints \\frac{1}{3} with 25 decimal places, we will see how R works with the number \\frac{1}{3}. You will see that it’s something like 0.3333333333333333148296163. After about 15-20 numbers after the decimal point we start seeing random numbers. This is because it was only precious up to 15-20 decimal places. For this course, however, the difference between integer and double vectors will not be important.↩︎"
  },
  {
    "objectID": "operations-on-vectors.html#indexing",
    "href": "operations-on-vectors.html#indexing",
    "title": "5  Operations on Vectors",
    "section": "5.1 Indexing",
    "text": "5.1 Indexing\nSuppose we have a vector a with 5 elements and we wanted to isolate the 3rd element of it. We can do this with what is called indexing. To get the 3rd element of a vector a, we do a[3]. Let’s see this with an example:\n\na &lt;- c(1, 2, 4, 3, 2)\na[3]\n\n[1] 4\n\n\nWe can also extract multiple elements of the vector using a vector of indices inside the []. For example, suppose we wanted to get the 1st, 3rd and 4th element of a. We would put the vector c(1, 3, 4) inside the square brackets:\n\na[c(1, 3, 4)]\n\n[1] 1 4 3\n\n\nWe can also extract elements of a vector using a logical vector. Doing this will extract the elements where the logical vector is TRUE. To do this, the logical vector needs to have the same length as the vector we are trying to index. Like above, if we want the 1st, 3rd and 4th element of a, we can use a vector with TRUE in the 1st, 3rd and 4th element and FALSE everywhere else:\n\na[c(TRUE, FALSE, TRUE, TRUE, FALSE)]\n\n[1] 1 4 3\n\n\nSuppose I want everything in a vector except one element: I want to exclude one element from the vector. For example, suppose I want to see the entire vector a except the 2nd element. We can do this using -2 in the brackets:\n\na[-2]\n\n[1] 1 4 3 2"
  },
  {
    "objectID": "operations-on-vectors.html#sequences",
    "href": "operations-on-vectors.html#sequences",
    "title": "5  Operations on Vectors",
    "section": "5.2 Sequences",
    "text": "5.2 Sequences\nOften it is useful to create a sequence of numbers. For a simple sequence like 1, 2, 3, …, 10, we can just do:\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWe can also make the sequence go backwards by reversing the numbers:\n\n10:1\n\n [1] 10  9  8  7  6  5  4  3  2  1\n\n\nFor sequences that don’t jump in 1s we can use the seq() function. Suppose we wanted to have a sequence from 10 to 100 with steps of 10. We do that with:\n\nseq(from = 10, to = 100, by = 10)\n\n [1]  10  20  30  40  50  60  70  80  90 100\n\n\nInstead of specifying the step length with by, we can alternatively specify the length of the sequence. Suppose I wanted to have a sequence going from 0 to 1 in equal steps with 5 numbers in total. I can do that using the length.out option:\n\nseq(from = 0, to = 1, length.out = 5)\n\n[1] 0.00 0.25 0.50 0.75 1.00"
  },
  {
    "objectID": "operations-on-vectors.html#repeating-numbers",
    "href": "operations-on-vectors.html#repeating-numbers",
    "title": "5  Operations on Vectors",
    "section": "5.3 Repeating Numbers",
    "text": "5.3 Repeating Numbers\nIf I wanted to create a vector which is 1 repeated 5 times, I could do:\n\nc(1, 1, 1, 1, 1)\n\n[1] 1 1 1 1 1\n\n\nBut this would get very annoying to type and I could easily make a mistake if I wanted to make many more 1s. If we want to repeat a number many times, we can use the rep() function. For example, if we want to make 100 1s, we would do:\n\nrep(1, times = 100)\n\n  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n [38] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n [75] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n\n\nAt the start of Chapter 3 we briefly mentioned that the [1] you see at the start of the output meant that the number we saw was the first one. Because with this example we have many numbers that run onto multiple lines, we can see a [38] at the start of line 2. This means that the first 1 on the 2nd line is the 38th element of the vector. The [75] on the 3rd line means the 1st one on that line is the 75th element.\nThe rep() function can also be combined with vectors. Suppose I wanted to repeat 1, 2, 3 four times:\n\nrep(1:3, times = 4)\n\n [1] 1 2 3 1 2 3 1 2 3 1 2 3\n\n\nAnd if I instead wanted to repeat 1, 2, 3, each 4 times, I would use the each option:\n\nrep(1:3, each = 4)\n\n [1] 1 1 1 1 2 2 2 2 3 3 3 3"
  },
  {
    "objectID": "operations-on-vectors.html#summary-statistics-for-vectors",
    "href": "operations-on-vectors.html#summary-statistics-for-vectors",
    "title": "5  Operations on Vectors",
    "section": "5.4 Summary Statistics for Vectors",
    "text": "5.4 Summary Statistics for Vectors\nWe can get summary statistics for vectors using functions. Let’s look at some common ones using a simple vector with the sequence 1 to 10:\n\na &lt;- 1:10\na\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nGet the number of elements of a:\n\nlength(a)\n\n[1] 10\n\n\nGet the minimum value in a:\n\nmin(a)\n\n[1] 1\n\n\nGet the maximum value in a:\n\nmax(a)\n\n[1] 10\n\n\nGet the average of all elements in a:\n\nmean(a)\n\n[1] 5.5\n\n\nGet the median of all elements in a:\n\nmedian(a)\n\n[1] 5.5\n\n\nNote on the median: Normally the median orders all elements of the vector and gives the element in the middle. Because we have an even number of elements in a (10 elements), the median is the average of the two values in the middle after sorting. Because it’s already sorted, these middle values are 5 and 6, so the median is (5+6)/2 = 5.5.\nGet the sum of all elements in a:\n\nsum(a)\n\n[1] 55\n\n\nA useful way to quickly summarize a numeric vector is with the summary() function, which gives the minimum, maximum, mean, median and interquartile range:\n\nsummary(a)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00    3.25    5.50    5.50    7.75   10.00 \n\n\nAnother useful way of summarizing data is to tabulate it: to count the number of occurrences of each value. We can do that with the table() function:\n\na &lt;- c(1, 3, 2, 4, 4, 2, 4)\ntable(a)\n\na\n1 2 3 4 \n1 2 1 3 \n\n\nThe output here means that 1 appeared once, 2 appeared twice, 3 appeared once and 4 appeared three times."
  },
  {
    "objectID": "comparing-vectors.html#comparing-numerical-vectors",
    "href": "comparing-vectors.html#comparing-numerical-vectors",
    "title": "6  Comparing Vectors",
    "section": "6.1 Comparing Numerical Vectors",
    "text": "6.1 Comparing Numerical Vectors\nConsider the following two vectors:\n\na &lt;- 1:5\na\n\n[1] 1 2 3 4 5\n\nb &lt;- 5:1\nb\n\n[1] 5 4 3 2 1\n\n\nTo find the indices of elements where a &gt; b, we can use a &gt; b. This returns a logical vector which is TRUE when a is greater than b and is FALSE otherwise:\n\na &gt; b\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\n\nThus a&gt;b in the 4th and 5th element only, as 4&gt;2 in the 4th element and 5&gt;1 in the 5th element.\nFor a\\geq b (greater than or equal to) we use a &gt;= b.\n\na &gt;= b\n\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n\n\nThe condition is satisfied in the 3rd element too, as 3\\geq 3.\nSimilarly, for “less than” we use &lt; and for less than or equal to we use &lt;=:\n\na &lt; b\n\n[1]  TRUE  TRUE FALSE FALSE FALSE\n\na &lt;= b\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\n\nFor a = b, we use a == b. We need to use two equal signs, because if we did a = b, it would replace the vector a with the vector b. Thus we use == to ask if the respective elements of the two vectors are equal:\n\na == b\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\n\nThus a=b only in the 3rd element.\nFor a \\neq b (a not equal to b), we use a != b:\n\na != b\n\n[1]  TRUE  TRUE FALSE  TRUE  TRUE\n\n\nIt’s also possible to compare a vector to a single number. For example, like:\n\na &gt; 3\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\n\nBut what is not possible is comparing a vector with 5 elements to a vector with only 4 elements. Either the two vectors should have the same length, or at least one of them has only 1 element."
  },
  {
    "objectID": "comparing-vectors.html#comparing-logical-vectors",
    "href": "comparing-vectors.html#comparing-logical-vectors",
    "title": "6  Comparing Vectors",
    "section": "6.2 Comparing Logical Vectors",
    "text": "6.2 Comparing Logical Vectors\nConsider the following two logical vectors:\n\na &lt;- c(TRUE, TRUE, FALSE, FALSE)\nb &lt;- c(TRUE, FALSE, TRUE, FALSE)\n\nIf we want to know where both a and b are TRUE, we use the logical AND operator &:\n\na & b\n\n[1]  TRUE FALSE FALSE FALSE\n\n\na and b are only both TRUE in first element.\nTo see when either a or b are TRUE, we use the logical OR operator |:\n\na | b\n\n[1]  TRUE  TRUE  TRUE FALSE\n\n\nAt least one of a or b are TRUE in all but the last element.\nSuppose we wanted to return a logical vector which tells us when both a and b are FALSE. We can do that using the logical NOT operator !. First let’s see what happens when we use the NOT operator on just a::\n\n!a\n\n[1] FALSE FALSE  TRUE  TRUE\n\n\nEssentially it just flips the TRUEs to FALSEs and the FALSEs to TRUEs. To see when both a are b are FALSE we do:\n\n!a & !b\n\n[1] FALSE FALSE FALSE  TRUE\n\n\nThus, this only happens in the 4th element."
  },
  {
    "objectID": "r-scripts.html#creating-a-new-r-script",
    "href": "r-scripts.html#creating-a-new-r-script",
    "title": "7  R Scripts",
    "section": "7.1 Creating a New R Script",
    "text": "7.1 Creating a New R Script\nTo get started, go to File \\rightarrow New File \\rightarrow R Script in RStudio. You can also use the Ctrl+Shift+N keyboard shortcut, or use the first toolbar button directly under File.\nNote to Mac Users: The keyboard shortcut will be Cmd+Shift+N on a Mac. In general you will replace Ctrl with Cmd (and Alt with Option) in all keyboard shortcuts that follow.\nTest it out by typing a few commands into the script:\n\na &lt;- 2\nb &lt;- 3\na + b\n\nNote: The Alt + - shortcut to type &lt;- also works in R scripts.\nYour code in the R script should look like this:\n\n\n\nR scripts in RStudio"
  },
  {
    "objectID": "r-scripts.html#running-the-commands-in-an-r-script",
    "href": "r-scripts.html#running-the-commands-in-an-r-script",
    "title": "7  R Scripts",
    "section": "7.2 Running the Commands in an R Script",
    "text": "7.2 Running the Commands in an R Script\nThere are several different ways to run the commands in an R script.\n\n7.2.1 Selecting Lines and Running\nOne way to run these lines is to do the following:\n\nSelect the lines, either with your mouse or with the keyboard shortcut Ctrl+A.\nRunning the selected lines, either with the Run toolbar button on top of the R script, or with the keyboard shortcut Ctrl+Enter.\n\nWhat is nice about this method is you can run a subset of the commands in your R script. Instead of selecting all the lines, you just select the lines you want to run. This can be useful if some of the lines in your code are slow to run and you don’t need to run those lines again.\n\n\n7.2.2 Sourcing\n\n7.2.2.1 Sourcing with Echo\nAnother way to run the entire script is to source the script. You can do this with the keyboard shortcut Ctrl+Shift+Enter or by clicking the down-arrow next to the Source button at the top of the script, and clicking “Source with Echo”.\nWith this approach you don’t need to select the lines first. It always runs the entire file. But keep in mind there is no way to run part of script with this method.\n\n\n7.2.2.2 Sourcing without Echo\nYou will notice that when you run source, the source() command appears in the console with the option echo = TRUE. The echo option prints all of the commands and the output on the screen. It is also possible to source without echo which then only prints what you want it to. This can be useful if you have a very long script and only want to see the output of a few different things in it when running it. You can do this by clicking the drop-down option next to the Source button and clicking “Source”. You can also use the keyboard shortcut Ctrl+Shift+S.\nIf we try this using the example script above we will see that it does not print anything at all. We don’t see the output of a + b. To be able to print the output of a line on the screen when using source() without echo, we need to use the print() function. We need to change our script to be:\n\na &lt;- 2\nb &lt;- 3\nprint(a + b)\n\nWhen we source the script without echo we then see the output:\n\n\n[1] 5"
  },
  {
    "objectID": "r-scripts.html#commenting-in-r",
    "href": "r-scripts.html#commenting-in-r",
    "title": "7  R Scripts",
    "section": "7.3 Commenting in R",
    "text": "7.3 Commenting in R\n\n7.3.1 Commenting as Annotation\nWhen writing an R script it is good practice to add comments throughout to explain what you are doing. This helps other people who are reading your code to understand what you are doing and your intentions. Most of all, though, it helps you to understand your code when you look back at it after a few months. To add a comment in R you simply need to type a # and anything you write after the # is not run by R. For example:\n\n# Set values of a and b:\na &lt;- 2\nb &lt;- 3\n# Compute the sum of a and b and print:\nprint(a + b)\n\n[1] 5\n\n\nYou can also add comments after a command on the same line. Everything before the # is run by R, and everything after and including the # is not run:\n\na &lt;- 2        # set a equal to 2\nb &lt;- 3        # set b equal to 3\nprint(a + b)  # Compute the sum of a and b and print:\n\n[1] 5\n\n\n\n\n7.3.2 Commenting to Not Run Certain Commands\nIf you have written some commands but you don’t want to run them when you run/source your script, you can “comment them out”. You just put a # before each line you don’t want to run to turn them into “comments”. You can “comment out” many lines at the same time by selecting the lines you want to comment out and using the Ctrl+Shift+C shortcut (or by going to Code \\rightarrow Comment/Uncomment Lines). If you want to “uncomment” these lines, you just need to select them and use the Ctrl+Shift+C shortcut again."
  },
  {
    "objectID": "reading-csv-datasets.html#structure-of-a-csv-file",
    "href": "reading-csv-datasets.html#structure-of-a-csv-file",
    "title": "8  Loading a CSV Dataset",
    "section": "8.1 Structure of a CSV file",
    "text": "8.1 Structure of a CSV file\nBefore learning how to read a CSV file into R, let’s first understand the structure of a CSV file.\nWe will do this with the example data.frame we saw before about how long it took people to travel to class. The dataset can be represented by the following table:\n\n\n\ntravel_mode\ntime\n\n\n\n\ntrain\n25\n\n\ntrain\n20\n\n\nwalk\n15\n\n\ncycle\n10\n\n\nwalk\n17\n\n\ntrain\n30\n\n\n\nA CSV file containing this dataset would look like this:\n\ntravel_mode,time\ntrain,25\ntrain,20\nwalk,15\ncycle,10\nwalk,17\ntrain,30\n\nIn a CSV dataset, the first row includes the names of the variables. Each of the names are separated by commas, hence the name “comma-separated values”. So the first line is travel_model,time. The second and following rows contain the values of each of the variables, again separated by commas. Each line needs to have the same number of commas so that the data can be read in as rectangular.\n\nCommas as Part of Character Variables\nSometimes the values of the variables contain commas. For example, a travel mode could be \"train,cycle\" if someone both cycled and took the train. If we put in a line like train,cycle,28 in the CSV file, it would think that there are 3 data points for that line, when there should be only 2. In order to distinguish when the comma is part of the data and when it separates columns, we can put the character variables in double quotation marks. So we could more safely store the dataset instead as follows:\n\n\"travel_mode\",\"time\"\n\"train\",25\n\"train\",20\n\"walk\",15\n\"cycle\",10\n\"walk\",17\n\"train\",30\n\n\n\nDecimal Commas in CSV Files\nOutside the Anglosphere (e.g. USA, UK, etc.), such as in the Netherlands, the decimal separator is a comma instead of a point. For example, “two and a half” is represented by 2,5 instead of 2.5. In this case we have two options:\n\nWe can surround all the numbers by double quotation marks.\nWe can use semicolons (;) to separate columns instead of commas, and inform R that we want to use semicolons as separators instead of commas.\n\nFor assignments and exams, however, we will always be dealing with datasets with period decimal separators."
  },
  {
    "objectID": "reading-csv-datasets.html#reading-in-a-csv-file",
    "href": "reading-csv-datasets.html#reading-in-a-csv-file",
    "title": "8  Loading a CSV Dataset",
    "section": "8.2 Reading in a CSV file",
    "text": "8.2 Reading in a CSV file\nWe will learn how to read in the example dataset above from a file. To do so, you need to first do the following steps to save it:\n\nCopy the text of the CSV file above using the clipboard icon.\nOpen a new text file with File \\rightarrow New File \\rightarrow Text File.\nPaste in the contents of your clipboard so the file has the data in it.\nGo to File \\rightarrow Save As... and save the file as test.csv somewhere on your computer.\n\nAlternatively, download the file here. The variable names and meanings are:\nNow, to read in the file into R, we need to tell R exactly where on your computer the file is. We need to give R either the absolute path (or full path) to the file, or the relative path.\n\n8.2.1 Absolute Paths\nThe absolute path is the full path to the file. On Windows the full path is something like C:\\Users\\username\\Documents\\test.csv. On a Mac, the full path is something like Users/username/Documents/test.csv.\nThere are many different ways you can find the full path of your file, but the most convenient way for our purposes is to use the file.choose() command. When you run the file.choose() command in your console, a file browser will appear:\n\n\n\nfile.choose() command\n\n\nYou then navigate to the file on your computer and press “Open”.\nAfter doing so, the full path of the file will print in the console surrounded by quotes:\n\n\n\nfile.choose() command\n\n\nWe can then copy this (leaving out the [1]) and paste it into the read.csv() command like this:\n\ndf &lt;- read.csv(\"e:\\\\Users\\\\cbtwalsh\\\\Documents\\\\test.csv\")\n\nRunning this will read in the file into a data.frame called df. We will then be able to see df in our Environment and can view it by clicking on it there, or else typing View(df) in the console.\nTechnical note: Windows users will notice that the file path used in the read.csv() command uses “double backslashes” (\\\\) instead of single backslashes that you would normally see in a file path. We need to use these double backslashes in R because R uses the single backslash as an “escape character”. To create a single actual backslash in R we always need to use two backslashes. This is another reason why using the file.choose() command to get the file path is so useful. Otherwise we would have to add in all the extra backslashes in manually. It’s also possible to use forward slashes (/) instead, in which case we only need to use one. For example: \"e:/Users/cbtwalsh/Documents/test.csv\".\n\n\n8.2.2 Relative Paths\nReading in a file using the absolute path like above works well until you start collaborating on a project with someone. Because you don’t have the same username, the code that you write won’t work on their computer because the file paths will be different. If two people are working on an R script together on Dropbox, they will have to constantly change the the lines in the R scripts that read in data.\nA solution to this is to use relative paths for reading in data, or better yet, projects in RStudio (see below).\nAt any given time, R has a current working directory which is a folder somewhere on your computer. You can find out where this is using the getwd() command. If the file test.csv is in the current working directory, you can read it in without using the full path:\n\ndf &lt;- read.csv(\"test.csv\")\n\nOne way to change the current working directory to the location where you have saved your data is to use the setwd() command. You can use the file.choose() command like before to navigate to where that is. You would then copy the full file path except for the part containing the file name. In the example above, you would do the following:\n\nsetwd(\"e:\\\\Users\\\\cbtwalsh\\\\Documents\\\\\")\ndf &lt;- read.csv(\"test.csv\")\n\nThis way, the collaborators would only need to set the current working directory once, and then the read.csv() commands wouldn’t need to be changed. This is useful when commands like this are run several times.\nSuppose the dataset wasn’t in e:\\Users\\cbtwalsh\\Documents, but rather e:\\Users\\cbtwalsh\\Documents\\datasets, a sub-folder of the Documents folder. We can still read in the file when the current directory is \"e:\\\\Users\\\\cbtwalsh\\\\Documents\\\\\" by using the relative path. That is, we only need to give the path relative to the current working directory. In this case, it would be \"datasets/test.csv\". Thus we could read in the data with:\n\nsetwd(\"e:\\\\Users\\\\cbtwalsh\\\\Documents\\\\\")\ndf &lt;- read.csv(\"datasets/test.csv\")\n\n\n\n8.2.3 RStudio Projects\nIf you are collaborating with someone, setting the current working directory in the way above still requires changing a line when you run it on a different computer, which is inconvenient. A way that avoids this entirely is the Project feature in RStudio.\n\n8.2.3.1 Creating an RStudio Projects\nTo make use of this feature, we first need to create a project. The easiest way to do this is to first ensure that the folder that you want to be the project already exists somewhere on your computer. You can go to File \\rightarrow New Project... (or click the Project toolbar button) select “Existing Directory” and then browse to the location on your computer where it is. Then click “Create Project” and R will switch to the project.\nHere are screenshots of the steps:\n\n\n\nStep 1: Click on the Project toolbar button.\n\n\n\n\n\nStep 2: Click on “New Project”.\n\n\n\n\n\nStep 3: Click on “Existing Directory”.\n\n\n\n\n\nStep 4: Click “Browse”.\n\n\n\n\n\nStep 5: Navigate to the project folder, click on it, and press “Open”.\n\n\n\n\n\nStep 6: Click “Create Project”.\n\n\n\n\n\nRStudio after creating the project.\n\n\nR then switches to the project. We can see that:\n\nThe Files tab now shows the files from the project folder.\nRStudio creates a file called my_new_project.Rproj in your project folder.\nWe can also see that R has switched its current working directory to the project folder. We can check this with the getwd() command:\n\n\n\n\nConfirming the new working directory with getwd()\n\n\n\n\n8.2.3.2 Reading in Data within an R Project\nTo read in a file in the project directory, such as test.csv, all we need to do is this:\n\ndf &lt;- read.csv(\"test.csv\")\n\nThis way, we don’t need to find and paste in the full file path, we don’t need to change the working directory, and if we are collaborating with someone we don’t ever need to change any of the lines. There are also a number of other (more advanced) benefits from using the Projects feature. For these reasons, I recommend always using the Project feature in RStudio."
  },
  {
    "objectID": "packages.html#example-setting-reading-excel-files",
    "href": "packages.html#example-setting-reading-excel-files",
    "title": "9  R Packages",
    "section": "9.1 Example Setting: Reading Excel Files",
    "text": "9.1 Example Setting: Reading Excel Files\nThere is no function in base R that allows you to easily read in an Excel file into R as a data.frame. One solution to this problem would be to export the data from the Excel file into a CSV file. In Excel you would do File \\rightarrow Save As and choose “CSV” under Save as type). Then we can just read in the data using the read.csv() function we learned about in Chapter 8.\nThis approach would work fine in many circumstances, but you might have a situation where you need to read many Excel files, or the Excel file is frequently being updated. Then always having to convert the file to CSV becomes very time-consuming and annoying. Also, we want to easily be able to replicate the steps in our work. By having all the steps you do in your R script, anyone can see exactly what you have done from the initial “raw data”. This makes your work replicable and transparent.\nThere are several R packages that allow you to read in Excel files, but we will focus our attention on one of them: the readxl package.\nTo test this out, open Excel and populate it with the data below and save it as test.xlsx in your project directory:\n\n\n\nx\ny\n\n\n\n\n3\n5\n\n\n8\n7\n\n\n2\n1"
  },
  {
    "objectID": "packages.html#installing-packages",
    "href": "packages.html#installing-packages",
    "title": "9  R Packages",
    "section": "9.2 Installing packages",
    "text": "9.2 Installing packages\n\n9.2.1 From the command line\nOne way to install a package is from the command line using the install.packages() function. You just need to put the package name in quotation marks as the argument:\n\ninstall.packages(\"readxl\")\n\nIf you include this line in your R script, it will re-install the package every time you run/source your code. For that reason it’s better to type it in the command line.\n\n\n9.2.2 From RStudio\nIn RStudio you can go to Tools \\rightarrow Install Packages..., type the name of the packages in the “Packages” box, and press “Install” (leaving all the other options as default). Here is an example:\n\n\n\nInstalling a package using the RStudio dialog box.\n\n\nNote: the computers on campus have a very wide range of packages already installed. In the exam you won’t have to install any packages."
  },
  {
    "objectID": "packages.html#loading-packages",
    "href": "packages.html#loading-packages",
    "title": "9  R Packages",
    "section": "9.3 Loading packages",
    "text": "9.3 Loading packages\nThe function from the readxl package that we want to use is called read_excel(). We want to use it to read in the test.xlsx file we created earlier. If we try to use the function with the command read_excel(\"test.xlsx\"), we will get the following error:\n\nThis is because simply installing a package doesn’t mean the functions are available to use. We need to load the package first. This is done using the library() function. When using the library() function, we don’t need to put the package name in quotes (but we still can – both work). This is unlike the install.packages() function, where quotes are required.\nAfter loading the package, we can read in the data from the Excel file:\n\nlibrary(readxl)\ndf &lt;- read_excel(\"test.xlsx\")\ndf\n\n# A tibble: 4 × 2\n      x     y\n  &lt;dbl&gt; &lt;dbl&gt;\n1     1     2\n2     4     4\n3     5     6\n4     3     3\n\n\nNote that the read_excel() function read in the data as a tibble, which is like a data.frame with a few extra features, like printing the dimensions of the data. For this course we can just think of tibbles and dataframes as the same thing. If you want to convert this tibble into a pure data.frame you can use the data.frame() function around read_excel():\n\ndf &lt;- data.frame(read_excel(\"test.xlsx\"))\ndf\n\n  x y\n1 1 2\n2 4 4\n3 5 6\n4 3 3\n\n\nFinally, note that if a package is not installed you will receive an error message. For example, if you tried to load the readxl package before installing it you would get the error:\n\n\nError in library(readxl) : there is no package called ‘readxl’\n\n\nWhen you get this error, you know you need to install the package first."
  },
  {
    "objectID": "packages.html#data-formats-from-other-software-optional",
    "href": "packages.html#data-formats-from-other-software-optional",
    "title": "9  R Packages",
    "section": "9.4 Data Formats from other Software (Optional)",
    "text": "9.4 Data Formats from other Software (Optional)\nIn the future you may encounter data files stored in other formats saved from other statistical software programs, such as Stata, SPSS or SAS. The haven package in R is able to read in each of these. You can install the haven package and load it like before:\n\ninstall.packages(\"haven\")\nlibrary(haven)\n\nThe functions to read in each of these data types are shown in the table below:\n\n\n\nStatistical Software\nFile extension\nFunction from haven package\n\n\n\n\nStata\n.dta\nread_stata()\n\n\nSPSS\n.sav\nread_spss()\n\n\nSAS\n.sas7bdat\nread_sas()\n\n\n\nIn the assignments and exam, however, we will not use any of these three data formats (.dta, .sav or .sas7bdat)."
  },
  {
    "objectID": "dataframes-indexing.html#running-example-the-eredivisie-results-from-202223",
    "href": "dataframes-indexing.html#running-example-the-eredivisie-results-from-202223",
    "title": "10  Dataframes: Indexing",
    "section": "10.1 Running Example: The Eredivisie Results from 2022/23",
    "text": "10.1 Running Example: The Eredivisie Results from 2022/23\nThe dataset we will work with in the next three chapters contains the team, number of wins, draws, losses, goals for, and goals against for all 18 teams and 38 matches from the 2022/23 season of the Eredivisie. The Eredivisie is the top Dutch association football league. Here, “goals for” means the total number of goals the team scored that season, whereas “goals against” is the total number of goals the team conceded that season.\nYou can copy the code chunk below directly into R and it will read the data in as a data.frame. This is another way of reading in datasets into R. You can provide the contents of a CSV file directly into the read.csv() function we have seen before instead of giving the filename. To do this we need to use the text option. I am doing it this way to save you time having to copy the data and save a new file on your computer, but it’s also good to see other ways of reading in data.\n\ndf &lt;- read.csv(text = \"\n            team, wins, draws, losses, goals_for, goals_against\n              AZ,   20,     7,      7,        68,            35\n            Ajax,   20,     9,      5,        86,            38\n       Excelsior,    9,     5,     20,        32,            71\n        FC Emmen,    6,    10,     18,        33,            65\n    FC Groningen,    4,     6,     24,        31,            75\n       FC Twente,   18,    10,      6,        66,            27\n      FC Utrecht,   15,     9,     10,        55,            50\n     FC Volendam,   10,     6,     18,        42,            71\n       Feyenoord,   25,     7,      2,        81,            30\n Fortuna Sittard,   10,     6,     18,        39,            62\n Go Ahead Eagles,   10,    10,     14,        46,            56\n             NEC,    8,    15,     11,        42,            45\n             PSV,   23,     6,      5,        89,            40\n    RKC Waalwijk,   11,     8,     15,        50,            64\n      SC Cambuur,    5,     4,     25,        26,            69\nSparta Rotterdam,   17,     8,      9,        60,            37\n         Vitesse,   10,    10,     14,        45,            50\n   sc Heerenveen,   12,    10,     12,        44,            50\n\", strip.white = TRUE)\n\nNote: The strip.white option I have used in this command is to remove the empty spaces before and after the team names."
  },
  {
    "objectID": "dataframes-indexing.html#indexing-with-dataframes",
    "href": "dataframes-indexing.html#indexing-with-dataframes",
    "title": "10  Dataframes: Indexing",
    "section": "10.2 Indexing with Dataframes",
    "text": "10.2 Indexing with Dataframes\nIn Chapter 5 we learned that we can get the 3rd element of a vector a with a[3]. We can also extract elements of a ataframe in a similar way. To get the 2nd row and 3rd column of a dataframe, we do:\n\ndf[2, 3]\n\n[1] 9\n\n\nInside the square bracket we first specify the rows, then after a comma we specify the columns.\nWe can also put multiple indexes in each part. Suppose we want a smaller dataframe of only the rows with Ajax, Feyenoord and PSV and only the columns with the team name and number of wins. We first check which rows those teams occupy (2, 9 and 13) and which columns those variables are in (1 and 2). We then do:\n\ndf[c(2, 9, 13), c(1, 2)]\n\n        team wins\n2       Ajax   20\n9  Feyenoord   25\n13       PSV   23\n\n\nIf we leave the columns part blank, it will give us the entire row. For example, to get all the results for just Ajax we just get the 2nd row:\n\ndf[2, ]\n\n  team wins draws losses goals_for goals_against\n2 Ajax   20     9      5        86            38\n\n\nSimilarly, if we leave the row part blank and only give column indices, it will give us all rows for those columns. If we just want the column of wins we can do:\n\ndf[, 2]\n\n [1] 20 20  9  6  4 18 15 10 25 10 10  8 23 11  5 17 10 12\n\n\nWe can also get a column of a dataframe using the name of the variable. For example, if we want to get the goals_for column, we can do:\n\ndf$goals_for\n\n [1] 68 86 32 33 31 66 55 42 81 39 46 42 89 50 26 60 45 44\n\n\nThe dollar symbol here is what is called an extraction operator. The dollar symbol is required because goals_for is part of df. The variable goals_for is not a standalone vector in our environment. The df$ tells R to look for goals_for inside df.\nWe can also use the name of the variable in the part where we specify the column indices:\n\ndf[, \"goals_for\"]\n\n [1] 68 86 32 33 31 66 55 42 81 39 46 42 89 50 26 60 45 44\n\n\nWe can also place multiple variable names in there:\n\ndf[, c(\"team\", \"goals_for\")]\n\n               team goals_for\n1                AZ        68\n2              Ajax        86\n3         Excelsior        32\n4          FC Emmen        33\n5      FC Groningen        31\n6         FC Twente        66\n7        FC Utrecht        55\n8       FC Volendam        42\n9         Feyenoord        81\n10  Fortuna Sittard        39\n11  Go Ahead Eagles        46\n12              NEC        42\n13              PSV        89\n14     RKC Waalwijk        50\n15       SC Cambuur        26\n16 Sparta Rotterdam        60\n17          Vitesse        45\n18    sc Heerenveen        44\n\n\nFinally, another way to get a single variable from a dataframe is to place the name of the variable in quotes inside double square brackets:\n\ndf[[\"goals_for\"]]\n\n [1] 68 86 32 33 31 66 55 42 81 39 46 42 89 50 26 60 45 44\n\n\nWe can also subset rows of a dataframe using logical operators, just like we saw in Chapter 5. For example, suppose we wanted to only see the results for teams that won at least 20 matches. The following will return a logical vector which is TRUE if the team won at least 20 matches, and FALSE if they won 19 or fewer matches:\n\ndf$wins &gt;= 20\n\n [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[13]  TRUE FALSE FALSE FALSE FALSE FALSE\n\n\nThe first two are TRUE, because AZ and Ajax won at least 20 matches (they both won exactly 20). The next two are FALSE because Excelsior and FC Emmen won less than 20 matches (they won 9 and 6, respectively).\nIf we use this inside the square brackets where we specify the row indices, we get the desired result:\n\ndf[df$wins &gt;= 20, ]\n\n        team wins draws losses goals_for goals_against\n1         AZ   20     7      7        68            35\n2       Ajax   20     9      5        86            38\n9  Feyenoord   25     7      2        81            30\n13       PSV   23     6      5        89            40"
  },
  {
    "objectID": "dataframes-creating-variables.html#goal-difference",
    "href": "dataframes-creating-variables.html#goal-difference",
    "title": "11  Dataframes: Creating Variables",
    "section": "11.1 Goal Difference",
    "text": "11.1 Goal Difference\nThe goal difference in association football is the number of goals for minus goals against. To create this variable we then simply need to subtract the variable goals_against from goals_for. How can we do that?\nTo get the goal difference then, we subtract df$goals_against from df$goals_for\n\ndf$goals_for - df$goals_against\n\n [1]  33  48 -39 -32 -44  39   5 -29  51 -23 -10  -3  49 -14 -43  23  -5  -6\n\n\nThis prints out the goal difference for all 18 teams, but it does not save it in the dataset. To do that, we need to assign this output to a new variable in df. We do that using the dollar symbol again:\n\ndf$goal_diff &lt;- df$goals_for - df$goals_against\n\nNow when we look at our dataset, there is a new variable in it:\n\ndf\n\n               team wins draws losses goals_for goals_against goal_diff\n1                AZ   20     7      7        68            35        33\n2              Ajax   20     9      5        86            38        48\n3         Excelsior    9     5     20        32            71       -39\n4          FC Emmen    6    10     18        33            65       -32\n5      FC Groningen    4     6     24        31            75       -44\n6         FC Twente   18    10      6        66            27        39\n7        FC Utrecht   15     9     10        55            50         5\n8       FC Volendam   10     6     18        42            71       -29\n9         Feyenoord   25     7      2        81            30        51\n10  Fortuna Sittard   10     6     18        39            62       -23\n11  Go Ahead Eagles   10    10     14        46            56       -10\n12              NEC    8    15     11        42            45        -3\n13              PSV   23     6      5        89            40        49\n14     RKC Waalwijk   11     8     15        50            64       -14\n15       SC Cambuur    5     4     25        26            69       -43\n16 Sparta Rotterdam   17     8      9        60            37        23\n17          Vitesse   10    10     14        45            50        -5\n18    sc Heerenveen   12    10     12        44            50        -6"
  },
  {
    "objectID": "dataframes-creating-variables.html#total-points",
    "href": "dataframes-creating-variables.html#total-points",
    "title": "11  Dataframes: Creating Variables",
    "section": "11.2 Total Points",
    "text": "11.2 Total Points\nIn association football leagues, a team gets 3 points for a win and 1 point for a draw. They get 0 points for a loss. The formula for calculating the total number of points is then: \n\\text{Points} = 3 \\times \\text{Wins} + 1 \\times \\text{Draws} + 0 \\times \\text{Losses}\n In our data we observe the number of wins, draws and losses, but not the total points. So we need to create this variable from the other ones using the formula above. We can do this with:\n\ndf$total_points &lt;- 3 * df$wins + df$draws\n\nWe didn’t need to include df$losses in the formula because when we multiply it by zero it won’t make a difference.\nLet’s take a look at what we’ve created:\n\ndf[, c(\"team\", \"wins\", \"draws\", \"losses\", \"total_points\")]\n\n               team wins draws losses total_points\n1                AZ   20     7      7           67\n2              Ajax   20     9      5           69\n3         Excelsior    9     5     20           32\n4          FC Emmen    6    10     18           28\n5      FC Groningen    4     6     24           18\n6         FC Twente   18    10      6           64\n7        FC Utrecht   15     9     10           54\n8       FC Volendam   10     6     18           36\n9         Feyenoord   25     7      2           82\n10  Fortuna Sittard   10     6     18           36\n11  Go Ahead Eagles   10    10     14           40\n12              NEC    8    15     11           39\n13              PSV   23     6      5           75\n14     RKC Waalwijk   11     8     15           41\n15       SC Cambuur    5     4     25           19\n16 Sparta Rotterdam   17     8      9           59\n17          Vitesse   10    10     14           40\n18    sc Heerenveen   12    10     12           46"
  },
  {
    "objectID": "dataframes-creating-variables.html#team-ranking",
    "href": "dataframes-creating-variables.html#team-ranking",
    "title": "11  Dataframes: Creating Variables",
    "section": "11.3 Team Ranking",
    "text": "11.3 Team Ranking\nAt the moment, the data are sorted alphabetically by team. But usually we see them sorted by their ranking in the league. What we will do now is sort the data by their ranking in the league, and also create a variable that shows the team’s rank in the league.\nIn association football leagues, teams are ranked by the number of points they accumulated throughout the season. If two teams have the same number of points, we rank teams by their goal difference.1\nWe can create a ranking by sorting the data by the number of points and goal difference. We can do that using the order() function in R. The first argument is what we want to sort by (total points). For breaking ties we can include additional arguments. By default, order() sorts ascending so to sort descending we need to use the option decreasing = TRUE.\nIf we use the order function by itself, we get:\n\norder(df$total_points, decreasing = TRUE)\n\n [1]  9 13  2  1  6 16  7 18 14 11 17 12  8 10  3  4 15  5\n\n\nThe 9 at the beginning means that the team with the most points is the one in the 9th position. Let’s check which one that was:\n\ndf[9, ]\n\n       team wins draws losses goals_for goals_against goal_diff total_points\n9 Feyenoord   25     7      2        81            30        51           82\n\n\nThis is correct, because Feyenoord won the competition. The 2nd number 13 means the team in the 13th position (PSV) came second.\nTo actually sort the data, we need to use this function when specifying the row indices:\n\ndf &lt;- df[order(df$total_points, decreasing = TRUE), ]\ndf[, c(\"team\", \"total_points\", \"goal_diff\")]\n\n               team total_points goal_diff\n9         Feyenoord           82        51\n13              PSV           75        49\n2              Ajax           69        48\n1                AZ           67        33\n6         FC Twente           64        39\n16 Sparta Rotterdam           59        23\n7        FC Utrecht           54         5\n18    sc Heerenveen           46        -6\n14     RKC Waalwijk           41       -14\n11  Go Ahead Eagles           40       -10\n17          Vitesse           40        -5\n12              NEC           39        -3\n8       FC Volendam           36       -29\n10  Fortuna Sittard           36       -23\n3         Excelsior           32       -39\n4          FC Emmen           28       -32\n15       SC Cambuur           19       -43\n5      FC Groningen           18       -44\n\n\nIf there are ties in total points, the function will keep the initial ordering. Here, both Go Ahead Eagles and Vitesse have 40 points, but Vitesse has a better goal difference (-5 instead of -10). But for the ranking to be correct, we need Vitesse to be ahead of Go Ahead Eagles. To do this, we add df$goal_diff as another argument to the order() function. This orders by goal difference whenever there is a tie in points:\n\ndf &lt;- df[order(df$total_points, df$goal_diff, decreasing = TRUE), ]\ndf[, c(\"team\", \"total_points\", \"goal_diff\")]\n\n               team total_points goal_diff\n9         Feyenoord           82        51\n13              PSV           75        49\n2              Ajax           69        48\n1                AZ           67        33\n6         FC Twente           64        39\n16 Sparta Rotterdam           59        23\n7        FC Utrecht           54         5\n18    sc Heerenveen           46        -6\n14     RKC Waalwijk           41       -14\n17          Vitesse           40        -5\n11  Go Ahead Eagles           40       -10\n12              NEC           39        -3\n10  Fortuna Sittard           36       -23\n8       FC Volendam           36       -29\n3         Excelsior           32       -39\n4          FC Emmen           28       -32\n15       SC Cambuur           19       -43\n5      FC Groningen           18       -44\n\n\nNow we get the right ordering. We can also confirm that there are no ties in both total points and goal difference.\nTo create the ranking variable we can simply create a sequence from 1 to 18. We can do this with 1:18. But another way to get 18 is to use nrow(df), which is the number of rows in df:\n\ndf$ranking &lt;- 1:nrow(df)\ndf[, c(\"team\", \"total_points\", \"goal_diff\", \"ranking\")]\n\n               team total_points goal_diff ranking\n9         Feyenoord           82        51       1\n13              PSV           75        49       2\n2              Ajax           69        48       3\n1                AZ           67        33       4\n6         FC Twente           64        39       5\n16 Sparta Rotterdam           59        23       6\n7        FC Utrecht           54         5       7\n18    sc Heerenveen           46        -6       8\n14     RKC Waalwijk           41       -14       9\n17          Vitesse           40        -5      10\n11  Go Ahead Eagles           40       -10      11\n12              NEC           39        -3      12\n10  Fortuna Sittard           36       -23      13\n8       FC Volendam           36       -29      14\n3         Excelsior           32       -39      15\n4          FC Emmen           28       -32      16\n15       SC Cambuur           19       -43      17\n5      FC Groningen           18       -44      18\n\n\nYou can confirm that this is the correct points, goal difference and rankings by checking the table here."
  },
  {
    "objectID": "dataframes-creating-variables.html#relegation-status",
    "href": "dataframes-creating-variables.html#relegation-status",
    "title": "11  Dataframes: Creating Variables",
    "section": "11.4 Relegation Status",
    "text": "11.4 Relegation Status\nThe last variable we will create is the relegation status. In the Eredivisie, the teams ranked 17th and 18th are automatically relegated to the lower “Keuken Kampioen” (Kitchen Champion) league (where Tilburg’s Willem II competed that year). The 16th team enters into a playoff with teams in the Keuken Kampioen league. We will create a character variable with this information.\nTo do this we first create a variable which is blank everywhere: (\"\"). We then fill in values depending on the rank of the team using indexing:\n\ndf$relegation_status &lt;- \"\"\ndf$relegation_status[df$ranking &lt; 16] &lt;- \"No relegation\"\ndf$relegation_status[df$ranking == 16] &lt;- \"Relegation playoffs\"\ndf$relegation_status[df$ranking == 17 |\n                     df$ranking == 18] &lt;- \"Automatic relegation\"\ndf[, c(\"team\", \"ranking\", \"relegation_status\")]\n\n               team ranking    relegation_status\n9         Feyenoord       1        No relegation\n13              PSV       2        No relegation\n2              Ajax       3        No relegation\n1                AZ       4        No relegation\n6         FC Twente       5        No relegation\n16 Sparta Rotterdam       6        No relegation\n7        FC Utrecht       7        No relegation\n18    sc Heerenveen       8        No relegation\n14     RKC Waalwijk       9        No relegation\n17          Vitesse      10        No relegation\n11  Go Ahead Eagles      11        No relegation\n12              NEC      12        No relegation\n10  Fortuna Sittard      13        No relegation\n8       FC Volendam      14        No relegation\n3         Excelsior      15        No relegation\n4          FC Emmen      16  Relegation playoffs\n15       SC Cambuur      17 Automatic relegation\n5      FC Groningen      18 Automatic relegation\n\n\nFor teams in rank 17 or 18, we use the logical OR operator: If the ranking is equal to 17 or equal to 18, we set the status to “Automatic relegation”.\nWriting df$ranking == 17 | df$ranking == 18 inside the brackets is quite long. If you had more numbers you wanted to compare the ranking to, it would become a really long command. Fortunately R has a special operator we can use as a shortcut: the %in% operator. We can use the %in% operator to do the same thing as follows:\n\ndf$relegation_status[df$ranking %in% 17:18] &lt;- \"Automatic relegation\"\n\nWhat is the %in% doing? When we write a %in% b we are checking for each element in a if there is a matching element somewhere in b. To see this at work, consider the following example:\n\na &lt;- 1:6\nb &lt;- c(3, 5, 7)\na %in% b\n\n[1] FALSE FALSE  TRUE FALSE  TRUE FALSE\n\n\nHere the 3rd and 5th element are TRUE, because the 3rd and 5th element of a (which are 3 and 5) are somewhere in b (3 and 5 are in b, but 1, 2, 4 and 6 aren’t). An equivalent way of doing it (but with more typing) would be to see if a=3 or a=5 or a=7 for each element (i.e. check for a match in any of the elements of b):\n\na == b[1] | a == b[2] | a == b[3]\n\n[1] FALSE FALSE  TRUE FALSE  TRUE FALSE\n\n\nIn the example above, we had df$ranking %in% 17:18. This returns TRUE if the team’s ranking was one of 17 or 18 and is FALSE otherwise."
  },
  {
    "objectID": "dataframes-creating-variables.html#footnotes",
    "href": "dataframes-creating-variables.html#footnotes",
    "title": "11  Dataframes: Creating Variables",
    "section": "",
    "text": "If they are also tied on their goal difference, we rank them on their goals scored, then head-to-head points, then head-to-head goal difference, then head-to-head away goals scored. If they are still tied they will play another match (possibly ending with penalties) if it is for 1st place, relegation, or a European league; otherwise they will draw a ranking randomly. Fortunately, as we will see we can determine a clear ranking based on only points and goal scored, so we won’t need to code all these possibilities here. But if we wanted to be very exact we should also included these extra possibilities in our code.↩︎"
  },
  {
    "objectID": "dataframes-summary-statistics.html#summary-for-dataframes",
    "href": "dataframes-summary-statistics.html#summary-for-dataframes",
    "title": "12  Dataframes: Summary Statistics",
    "section": "12.1 summary() for Dataframes",
    "text": "12.1 summary() for Dataframes\nTo get a broad overview of a dataset, you can use the summary() function that we used in Chapter 5 before for vectors. When we use this function on a dataframe, it will show the summary statistics for all variables in the dataframe:\n\nsummary(df)\n\n     team                wins           draws            losses     \n Length:18          Min.   : 4.00   Min.   : 4.000   Min.   : 2.00  \n Class :character   1st Qu.: 9.25   1st Qu.: 6.000   1st Qu.: 7.50  \n Mode  :character   Median :10.50   Median : 8.000   Median :13.00  \n                    Mean   :12.94   Mean   : 8.111   Mean   :12.94  \n                    3rd Qu.:17.75   3rd Qu.:10.000   3rd Qu.:18.00  \n                    Max.   :25.00   Max.   :15.000   Max.   :25.00  \n   goals_for     goals_against     goal_diff      total_points  \n Min.   :26.00   Min.   :27.00   Min.   :-44.0   Min.   :18.00  \n 1st Qu.:39.75   1st Qu.:38.50   1st Qu.:-27.5   1st Qu.:36.00  \n Median :45.50   Median :50.00   Median : -5.5   Median :40.50  \n Mean   :51.94   Mean   :51.94   Mean   :  0.0   Mean   :46.94  \n 3rd Qu.:64.50   3rd Qu.:64.75   3rd Qu.: 30.5   3rd Qu.:62.75  \n Max.   :89.00   Max.   :75.00   Max.   : 51.0   Max.   :82.00  \n    ranking     \n Min.   : 1.00  \n 1st Qu.: 5.25  \n Median : 9.50  \n Mean   : 9.50  \n 3rd Qu.:13.75  \n Max.   :18.00  \n\n\nFor the team name, it just says character, because we cannot find the mean of a character. The only information we get is the number of observations (18). All the other variables are numeric, and the summary statistics are shown for each one."
  },
  {
    "objectID": "dataframes-summary-statistics.html#head-and-tail",
    "href": "dataframes-summary-statistics.html#head-and-tail",
    "title": "12  Dataframes: Summary Statistics",
    "section": "12.2 head() and tail()",
    "text": "12.2 head() and tail()\nAnother way to get a broad overview of a dataset is to just “eyeball” it by displaying it in the console with df, or browsing it in RStudio with View(df). For datasets with many observations, however, it may be easier to just look at the first few rows. We can do that with the head() function:\n\nhead(df)\n\n               team wins draws losses goals_for goals_against goal_diff\n9         Feyenoord   25     7      2        81            30        51\n13              PSV   23     6      5        89            40        49\n2              Ajax   20     9      5        86            38        48\n1                AZ   20     7      7        68            35        33\n6         FC Twente   18    10      6        66            27        39\n16 Sparta Rotterdam   17     8      9        60            37        23\n   total_points ranking\n9            82       1\n13           75       2\n2            69       3\n1            67       4\n6            64       5\n16           59       6\n\n\nBy default, head() shows the first 6 rows. We can look at a different number by specifying the option n. For example, to see the first 4 rows we would do:\n\nhead(df, n = 4)\n\n        team wins draws losses goals_for goals_against goal_diff total_points\n9  Feyenoord   25     7      2        81            30        51           82\n13       PSV   23     6      5        89            40        49           75\n2       Ajax   20     9      5        86            38        48           69\n1         AZ   20     7      7        68            35        33           67\n   ranking\n9        1\n13       2\n2        3\n1        4\n\n\nThe function tail() does the exact opposite. It shows the last n rows of the dataset, with 6 rows by default. To see the two teams that are automatically relegated (the bottom 2) we would do:\n\ntail(df, n = 2)\n\n           team wins draws losses goals_for goals_against goal_diff\n15   SC Cambuur    5     4     25        26            69       -43\n5  FC Groningen    4     6     24        31            75       -44\n   total_points ranking\n15           19      17\n5            18      18"
  },
  {
    "objectID": "dataframes-summary-statistics.html#nrow-and-ncol",
    "href": "dataframes-summary-statistics.html#nrow-and-ncol",
    "title": "12  Dataframes: Summary Statistics",
    "section": "12.3 nrow() and ncol()",
    "text": "12.3 nrow() and ncol()\nSomething we are often interested in is the total number of observations. We can find this by checking the number of rows in the dataframe with the nrow() function. In this case it is the number of teams. The number of columns (found with ncol()) shows the total number of variables.\n\nnrow(df)\n\n[1] 18\n\nncol(df)\n\n[1] 9\n\n\nIf we want to quickly find both of these numbers, we can also use the dim() function, which shows the dimensions of the dataframe (first the number of rows, then the number of columns):\n\ndim(df)\n\n[1] 18  9"
  },
  {
    "objectID": "dataframes-summary-statistics.html#names",
    "href": "dataframes-summary-statistics.html#names",
    "title": "12  Dataframes: Summary Statistics",
    "section": "12.4 names()",
    "text": "12.4 names()\nSometimes we are just interested in what variables are included in the dataset. To see this, we can use the names() function:\n\nnames(df)\n\n[1] \"team\"          \"wins\"          \"draws\"         \"losses\"       \n[5] \"goals_for\"     \"goals_against\" \"goal_diff\"     \"total_points\" \n[9] \"ranking\""
  },
  {
    "objectID": "data-cleaning.html#skipping-rows",
    "href": "data-cleaning.html#skipping-rows",
    "title": "13  Data Cleaning",
    "section": "13.1 Skipping Rows",
    "text": "13.1 Skipping Rows\nWhen we open the data we immediately notice that the first 3 rows contain information about the data that we don’t want to include in our dataframe. The variable names are on line 4 instead of line 1.\nOne option would be to delete those rows in Excel and save the file. However, it is best practice to avoid doing that and working with the raw CSV file as it was downloaded. This makes it easier to reproduce your work and show your steps through your R script. Fortunately the read.csv() function has an option to skip rows. We can use this with:\n\ndf &lt;- read.csv(\"asml-trades.csv\", skip = 3)\n\nWe could also have read in the data directly from the URL with:\n\ndf &lt;- read.csv(\"https://walshc.github.io/pqs/asml-trades.csv\", skip = 3)\n\nThis way we wouldn’t have to set up an RStudio project or change the working directory.\nLet’s take a first look at the data with summary():\n\nsummary(df)\n\n     Date                Open            High            Low       \n Length:521         Min.   :394.7   Min.   :408.2   Min.   :375.8  \n Class :character   1st Qu.:535.5   1st Qu.:545.5   1st Qu.:525.8  \n Mode  :character   Median :592.1   Median :597.4   Median :582.5  \n                    Mean   :589.2   Mean   :597.5   Mean   :579.6  \n                    3rd Qu.:645.5   3rd Qu.:652.5   3rd Qu.:636.1  \n                    Max.   :770.5   Max.   :777.5   Max.   :764.2  \n                    NA's   :6       NA's   :6       NA's   :6      \n      Last           Close       Number.of.Shares   Number.of.Trades  \n Min.   :397.4   Min.   :397.4   Length:521         Length:521        \n 1st Qu.:535.9   1st Qu.:535.9   Class :character   Class :character  \n Median :589.4   Median :589.4   Mode  :character   Mode  :character  \n Mean   :588.4   Mean   :588.4                                        \n 3rd Qu.:644.0   3rd Qu.:644.0                                        \n Max.   :770.5   Max.   :770.5                                        \n NA's   :6       NA's   :6                                            \n Print.table   \n Mode:logical  \n NA's:521      \n               \n               \n               \n               \n               \n\n\nFrom this we can see a few problems:\n\nFrom the summary of the Date variable, we can see that R read it in as a character. It did not recognize that it was a date.\nThe variables Open, High, Low, Last and Close contain 6 NAs. NA stands for “Not Available” and is what R uses to represent missing values.\nFor the variables Number.of.Shares and Number.of.Trades, we can see that they were read in as characters instead of numbers.\nPrint.table has 521 NAs (all values are NA), thus this variable is useless and should be deleted.\nWe also want to change some of the variable names and also change the names to lower case and replace the dots (.) with underscores (_).\n\nWe will work through these problems for the rest of this chapter."
  },
  {
    "objectID": "data-cleaning.html#formatting-dates",
    "href": "data-cleaning.html#formatting-dates",
    "title": "13  Data Cleaning",
    "section": "13.2 Formatting Dates",
    "text": "13.2 Formatting Dates\n\n13.2.1 Converting Dates in the ASML Example\nWe will start by converting the date variable from a character to a date variable. This is useful for doing operations with the date (such as subsetting the data on observations before/after a particular date) and for plotting.\nWe can convert the character to a date using the as.Date() function. The first argument of the function is the vector of dates that need to be converted, and the format argument specifies the format the date is written in. Let’s see what format the dates are written in using the head() command to see the first few rows:\n\nhead(df$Date)\n\n[1] \"31/8/2021\" \"1/9/2021\"  \"2/9/2021\"  \"3/9/2021\"  \"6/9/2021\"  \"7/9/2021\" \n\n\nWhen we look at the data, we can see that the format is dd/mm/yyyy. To specify this we need to write format = \"%d/%m/%Y\".\n\ndf$Date &lt;- as.Date(df$Date, format = \"%d/%m/%Y\")\n\nWe can check what this did with the head() command again:\n\nhead(df$Date)\n\n[1] \"2021-08-31\" \"2021-09-01\" \"2021-09-02\" \"2021-09-03\" \"2021-09-06\"\n[6] \"2021-09-07\"\n\n\nDates in R show up in the format yyyy-mm-dd. This is the default format.\nNow that the date is formatted correctly, the summary() command shows the first and last dates in the data (31 August 2021 and 29 August 2023):\n\nsummary(df$Date)\n\n        Min.      1st Qu.       Median         Mean      3rd Qu.         Max. \n\"2021-08-31\" \"2022-03-01\" \"2022-08-30\" \"2022-08-29\" \"2023-02-28\" \"2023-08-29\" \n\n\n\n\n13.2.2 Converting Dates from Other Formats\nDates in the Netherlands are typically written like dd-mm-yyyy. If it was the case we would instead do \"%d-%m-%Y\". You can try this out with:\n\nas.Date(\"1-9-2023\", format = \"%d-%m-%Y\")\n\n[1] \"2023-09-01\"\n\n\nIf the dates were in mm/dd/yyyy format, as is typical in USA, we would do \"%m/%d/%Y\".\n\nas.Date(\"12/31/2022\", format = \"%m/%d/%Y\")\n\n[1] \"2022-12-31\"\n\n\nSometimes we omit the century from years. We might write the 1st of September 2023 as 01/09/23. In R we need to use %y instead of %Y for these abbreviated years:1\n\nas.Date(\"01/09/22\", format = \"%d/%m/%y\")\n\n[1] \"2022-09-01\"\n\n\n\n\n13.2.3 Converting Dates with Month Names (Optional)\nSometimes the dates have the month name in words. To convert this we need to use the %b option for abbreviated month names and %B for full month names:\n\nas.Date(\"Sep 1 2023\", format = \"%b %d %Y\")\n\n[1] \"2023-09-01\"\n\nas.Date(\"January 1 2023\", format = \"%B %d %Y\")\n\n[1] \"2023-01-01\"\n\n\nNote that if your computer is not in English it might not work as R expects to read months in the language of your computer. To get around this, you can first set the language for dates to English using the Sys.setlocale() function before formatting the dates. Because of the complications with month names in different languages, I will not ask questions on the assignments or exam involving this. I am just providing this information in case it may be useful for you later."
  },
  {
    "objectID": "data-cleaning.html#converting-characters-to-numbers",
    "href": "data-cleaning.html#converting-characters-to-numbers",
    "title": "13  Data Cleaning",
    "section": "13.3 Converting Characters to Numbers",
    "text": "13.3 Converting Characters to Numbers\nFor the variables Number.of.Shares and Number.of.Trades, we saw that they were read in as characters instead of numbers. Usually this happens when there are some letters or other non-numeric symbols (like the % symbol) somewhere in the data. This is because all elements of vectors in R (the individual columns of a data.frame) must have the same data type. If there are any character elements in a vector, the remaining elements are coerced into characters.\nIf we look through the data we can see that some rows have \"None\" written instead of NA.2\nTo do this conversion we first replace the \"None\" values with NA. We do this by assigning NA to the subset of values where df$Number.of.Shares == \"None\":3\n\ndf$Number.of.Shares[df$Number.of.Shares == \"None\"] &lt;- NA\n\nOnce we have done this we use the as.numeric() function to convert the values from character to numeric:\n\ndf$Number.of.Shares &lt;- as.numeric(df$Number.of.Shares)\n\nNow when we summarize we see that it’s treated as a number:\n\nsummary(df$Number.of.Shares)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  84141  571178  711067  783291  916000 2932273       6 \n\n\nWe can do the same with the Number.of.Trades. We are also able to do this skipping the step of converting the \"None\" to NA:\n\ndf$Number.of.Trades &lt;- as.numeric(df$Number.of.Trades)\n\nWarning: NAs introduced by coercion\n\n\nWhen we do this, however, we see that R warned us that it converted some observations to NA. A warning is different to an error in that R still completes the operation (in an error it will just stop). But it is warning us because we may not have expected some values to be forced to NA. In general it is better to code in a way that doesn’t generate warnings, so I recommend setting the non-numeric values to NA first."
  },
  {
    "objectID": "data-cleaning.html#deleting-columns",
    "href": "data-cleaning.html#deleting-columns",
    "title": "13  Data Cleaning",
    "section": "13.4 Deleting columns",
    "text": "13.4 Deleting columns\nThe last column of the data, Print.table, contains no data. It has NA for all rows.\nTo delete a variable we write over the variable with NULL. This essentially replaces it with nothing:\n\ndf$Print.table &lt;- NULL\n\nAn alternative approach would be to use the column index of the variable we want to drop. Print.table is the 9th column in the data, and to drop the 9th column we could use:\n\ndf &lt;- df[, -9]\n\nIf we view the data in RStudio, we can see that it is now deleted."
  },
  {
    "objectID": "data-cleaning.html#dropping-rows-with-missing-data",
    "href": "data-cleaning.html#dropping-rows-with-missing-data",
    "title": "13  Data Cleaning",
    "section": "13.5 Dropping rows with missing data",
    "text": "13.5 Dropping rows with missing data\nLet’s take a look at how our data look now:\n\nsummary(df)\n\n      Date                 Open            High            Low       \n Min.   :2021-08-31   Min.   :394.7   Min.   :408.2   Min.   :375.8  \n 1st Qu.:2022-03-01   1st Qu.:535.5   1st Qu.:545.5   1st Qu.:525.8  \n Median :2022-08-30   Median :592.1   Median :597.4   Median :582.5  \n Mean   :2022-08-29   Mean   :589.2   Mean   :597.5   Mean   :579.6  \n 3rd Qu.:2023-02-28   3rd Qu.:645.5   3rd Qu.:652.5   3rd Qu.:636.1  \n Max.   :2023-08-29   Max.   :770.5   Max.   :777.5   Max.   :764.2  \n                      NA's   :6       NA's   :6       NA's   :6      \n      Last           Close       Number.of.Shares  Number.of.Trades\n Min.   :397.4   Min.   :397.4   Min.   :  84141   Min.   :  4398  \n 1st Qu.:535.9   1st Qu.:535.9   1st Qu.: 571178   1st Qu.: 26290  \n Median :589.4   Median :589.4   Median : 711067   Median : 33375  \n Mean   :588.4   Mean   :588.4   Mean   : 783291   Mean   : 35830  \n 3rd Qu.:644.0   3rd Qu.:644.0   3rd Qu.: 916000   3rd Qu.: 42707  \n Max.   :770.5   Max.   :770.5   Max.   :2932273   Max.   :108957  \n NA's   :6       NA's   :6       NA's   :6         NA's   :6       \n\n\nWe can see that there are 6 NAs for all variables except the Date variable. If we scroll through the data we notice that 6 rows with NAs are the same for all variables. Let’s have a look at what dates these are. We can do this using the is.na() function. This function, when applied to a vector, returns TRUE if the element is NA and FALSE if not. To see the dates when the variables are missing, we can do:\n\ndf$Date[is.na(df$Open)]\n\n[1] \"2022-04-15\" \"2022-04-18\" \"2022-12-26\" \"2023-04-07\" \"2023-04-10\"\n[6] \"2023-05-01\"\n\n\nWe can see that the missings were:\n\n2022-04-15: Good Friday\n2022-04-18: Easter Monday (Tweede paasdag)\n2022-12-26: Day after Christmas (Tweede kerstdag)\n2023-04-07: Good Friday\n2023-04-10: Easter Monday (Tweede paasdag)\n2023-05-01: Labor Day (Dag van de Arbeid)\n\nThese are weekdays where the Amsterdam stock market is closed. We can drop rows with any missings using the na.omit() function. I will print the number of rows in df before and after the operation to show what is happening:\n\nnrow(df)\n\n[1] 521\n\ndf &lt;- na.omit(df)\nnrow(df)\n\n[1] 515\n\n\nWe can see that we fell from 521 observations to 515 after deleting the 6 holidays from the data."
  },
  {
    "objectID": "data-cleaning.html#renaming-variables",
    "href": "data-cleaning.html#renaming-variables",
    "title": "13  Data Cleaning",
    "section": "13.6 Renaming Variables",
    "text": "13.6 Renaming Variables\nAlthough the variable names are quite okay, suppose we wanted to change some of them.\nSuppose we wanted to change the name of \"Number.of.Shares\" to \"num_shares\" to make it shorter to type, and to replace the dot with an underscore. Because we know it occupies the 7th column, we can change the name with:\n\nnames(df)[7] &lt;- \"num_shares\"\n\nSuppose we also wanted to change the name of \"Number.of.Trades\" to \"num_trades\". Counting columns like we did above increases our chances of making a mistake (besides, we need to do lots of counting). We can instead change the name using the old name as follows:\n\nnames(df)[names(df) == \"Number.of.Trades\"] &lt;- \"num_trades\"\n\nHow this works is names(df) == \"Number.of.Trades\" is TRUE only in the 8th column when the name is actually \"Number.of.Trades\", and so it changes the name of only that column.\nWe can also change the names of multiple columns at the same time. Suppose we wanted to change Open, High, Low and Last to lower case. We can do:\n\nnames(df)[2:5] &lt;- c(\"open\", \"high\", \"low\", \"last\")\n\nIf we wanted to quickly change all variable names to lower case, we can use the tolower() function. The tolower() function converts upper case characters to lower case:\n\ntest &lt;- c(\"hello!\", \"HELLO!\", \"Hello!\", \"HeLlO!\")\ntolower(test)\n\n[1] \"hello!\" \"hello!\" \"hello!\" \"hello!\"\n\n\nLet’s use it to change the names of the data set:\n\nnames(df) &lt;- tolower(names(df))\nnames(df)\n\n[1] \"date\"       \"open\"       \"high\"       \"low\"        \"last\"      \n[6] \"close\"      \"num_shares\" \"num_trades\""
  },
  {
    "objectID": "data-cleaning.html#footnotes",
    "href": "data-cleaning.html#footnotes",
    "title": "13  Data Cleaning",
    "section": "",
    "text": "If the date is 01/01/69, the format %d/%m/%y will interpret it as January 1 1969. But if the date is 01/01/68, it will interpret it as January 1 2068. All short-format years after 69 are put in the 1900s and all short-format years before 69 are put in the 2000s. You don’t need to remember these details for the exam though because we won’t ever use dates outside of 1969-2068.↩︎\nAs a shortcut, we could have found all the non-numeric characters in a variable using the following command: unique(grep(\"[^0-9]\", df$Number.of.Trades, value = TRUE)). You don’t need to remember this command for the exam.↩︎\nWe could also have replaced all elements with non-numeric characters without knowing what they are with the following: df$Number.of.Shares[grepl(\"[^0-9]\", df$Number.of.Trades)] &lt;- NA. You don’t need to remember this command for the exam.↩︎"
  },
  {
    "objectID": "intro-to-plotting.html#introduction",
    "href": "intro-to-plotting.html#introduction",
    "title": "14  Introduction to Plotting",
    "section": "14.1 Introduction",
    "text": "14.1 Introduction\nWe will now learn some techniques to visualize your data. We will learn how to create histograms, bar charts, line plots, scatter plots, among others, and how to customize them.\nBase R (R without any packages) has some basic plotting functions. These are easy to use but they are not easily customizable and don’t look very elegant. For that reason we will also learn how to use the popular plotting package ggplot2. But in this chapter we stick to base R, leaving ggplot for later chapters."
  },
  {
    "objectID": "intro-to-plotting.html#example-setting-penguins",
    "href": "intro-to-plotting.html#example-setting-penguins",
    "title": "14  Introduction to Plotting",
    "section": "14.2 Example Setting: Penguins",
    "text": "14.2 Example Setting: Penguins\nTo get started on some basic plotting techniques we will use the famous “Palmer Penguins” dataset. This dataset contains several measurements of different penguins collected by researchers on Antwerp Island in the Palmer Archipelago of Antarctica. Interestingly, there is a smaller island next to this called Brabant Island.\nThe dataset contains data from three species of penguins: the Adelie, Chinstrap and Gentoo. A picture of each species is shown in the pictures below:\n\n  \n\nThis dataset is convenient to use because we can load it into R straight from a package. First install the package with the dataset with:\n\ninstall.packages(\"palmerpenguins\")\n\nThen load it with:\n\nlibrary(palmerpenguins)\ndata(penguins)\n\nRunning the command data(penguins) loads up two datasets: penguins and penguins_raw. We will ignore the penguins_raw dataset and only work with the penguins one."
  },
  {
    "objectID": "intro-to-plotting.html#data-inspection",
    "href": "intro-to-plotting.html#data-inspection",
    "title": "14  Introduction to Plotting",
    "section": "14.3 Data Inspection",
    "text": "14.3 Data Inspection\nBefore getting started with plotting, it’s good to first get a basic understanding of our data. Let’s get some summary statistics with summary() and find out how many observations with have with nrow():\n\nsummary(penguins)\n\n      species          island    bill_length_mm  bill_depth_mm  \n Adelie   :152   Biscoe   :168   Min.   :32.10   Min.   :13.10  \n Chinstrap: 68   Dream    :124   1st Qu.:39.23   1st Qu.:15.60  \n Gentoo   :124   Torgersen: 52   Median :44.45   Median :17.30  \n                                 Mean   :43.92   Mean   :17.15  \n                                 3rd Qu.:48.50   3rd Qu.:18.70  \n                                 Max.   :59.60   Max.   :21.50  \n                                 NA's   :2       NA's   :2      \n flipper_length_mm  body_mass_g       sex           year     \n Min.   :172.0     Min.   :2700   female:165   Min.   :2007  \n 1st Qu.:190.0     1st Qu.:3550   male  :168   1st Qu.:2007  \n Median :197.0     Median :4050   NA's  : 11   Median :2008  \n Mean   :200.9     Mean   :4202                Mean   :2008  \n 3rd Qu.:213.0     3rd Qu.:4750                3rd Qu.:2009  \n Max.   :231.0     Max.   :6300                Max.   :2009  \n NA's   :2         NA's   :2                                 \n\nnrow(penguins)\n\n[1] 344\n\n\nWe see that we have data on 344 penguins with the following variables:\n\nspecies: A factor variable indicating which of the 3 species the penguin is.\nisland: A factor variable indicating which island the penguin was on.\nbill_length_mm: A numerical variable indicating how long the penguin’s bill (their beak) was (in mm).\nbill_depth_mm: A numerical variable indicating how deep the penguin’s bill was (in mm). The depth is the distance between the top and bottom of their beak.\nflipper_length_mm: A numerical variable indicating how long their flipper (wing) is (in mm).\nbody_mass_g: A numerical variable indicating how heavy the penguin is (in grams).\nsex: A factor variable indicating the gender of the penguins (male or female).\nyear: A numerical variable indicating what year the data point is from.\n\nWe also see that we have 2 missing values for 4 of the variables and 11 missing values for sex. For our purposes here it is fine to just leave these missings in the dataset. We don’t need to delete those rows."
  },
  {
    "objectID": "intro-to-plotting.html#basic-plotting-with-base-r",
    "href": "intro-to-plotting.html#basic-plotting-with-base-r",
    "title": "14  Introduction to Plotting",
    "section": "14.4 Basic Plotting with Base R",
    "text": "14.4 Basic Plotting with Base R\nWe will now learn how to do some very simple plots with base R: the histogram, the bar plot and the scatter plot. The plots from base R are not very beautiful, but the idea is to learn how to make “quick and dirty” plots for you to quickly get a sense of your data, before making nicer customizable plots with ggplot.\n\n14.4.1 Histograms\nTo describe the distribution of a single numeric variable, we can use a histogram. A histogram splits the data into “bins” and shows the number of observations in each bin. We can create a histogram by using the hist() function, putting the variable we want to plot as the argument inside:\n\nhist(penguins$body_mass_g)\n\n\n\n\n\n\n14.4.2 Bar Plot\nFor categorical variables, we can use a bar plot to visualize the relative frequencies of different categories. We already saw the table() function which counts the number of times each category appears:\n\ntable(penguins$species)\n\n\n   Adelie Chinstrap    Gentoo \n      152        68       124 \n\n\nIf we want to plot these values, we can put this entire expression into the barplot() function:\n\nbarplot(table(penguins$species))\n\n\n\n\n\n\n14.4.3 Scatter Plots\nTo quickly visualize the relationship between two variables we can make a scatter plot. We can do this by listing the two variables we want to plot as arguments in the plot() function:\n\nplot(penguins$bill_length_mm, penguins$flipper_length_mm)\n\n\n\n\nIn each case, the base R commands to make plots are very short and easy to use. Therefore I use them very frequently in the console to learn what a dataset looks like. But because they do not look very nice I do not tend to use them in research papers. I prefer to use the plots from ggplot, which we will learn about next."
  },
  {
    "objectID": "plotting-with-ggplot.html#introduction",
    "href": "plotting-with-ggplot.html#introduction",
    "title": "15  Data Visualization with ggplot",
    "section": "15.1 Introduction",
    "text": "15.1 Introduction\nggplot is the main data visualization package in R. The gg in the name refers to “Grammar of Graphics” which is a scheme of layering different parts of a plot. As we will learn, ggplot() works by adding layers.\nTo get started, we first need to install and load the ggplot2 package. The name of the package is ggplot2 (with a 2), but the function we use to make the plots is just ggplot (without a 2).\n\ninstall.packages(\"ggplot2\")\nlibrary(ggplot2)\n\nWe also load the same penguins data like we saw in Chapter 14:\n\nlibrary(palmerpenguins)\ndata(penguins)\n\nWe will begin by recreating the plots we saw in Chapter 14 and customizing them to our liking."
  },
  {
    "objectID": "plotting-with-ggplot.html#histograms",
    "href": "plotting-with-ggplot.html#histograms",
    "title": "15  Data Visualization with ggplot",
    "section": "15.2 Histograms",
    "text": "15.2 Histograms\n\n15.2.1 Basic Histogram\nLet’s first show how to make a basic histogram (without customization) and then describe the different parts of the function:\n\nggplot(penguins, aes(body_mass_g)) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 2 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\n\n\n\n\nWith ggplot(), the first argument you provide is the dataframe with the variables you want to plot. Here it’s the penguins dataframe. The second argument is the “mapping” which we provide using the aes() (aesthetics) function. For a histogram we only need to provide one variable. Because we already tell ggplot the name of the dataframe, we only provide the variable name body_mass_g here instead of typing penguins$body_mass_g.\nThe next thing we do is add layers. We do this using the sum operator, +. To tell ggplot to add a histogram to the plot, we add geom_histogram(). It’s good practice to put the layers on different lines to make them easier to read, as later on we’ll see that we can use many layers.\nWe can see that ggplot gave 2 warnings when we did this command:\n\nIt tells us its using 30 bins and tells us how we can change this.\nWarning: Removed 2 rows containing non-finite values is telling us that our data contain 2 NA values that weren’t included in the plot. This is expected, because in Chapter 14 we saw that our dataset contains some missing observations.\n\n\n\n15.2.2 Customizing a Histogram\nTo customize the plot, we can use options in the functions, and add more layers to the plot. There are many possibilities here. Let’s see some of these:\n\n15.2.2.1 Changing the number of bins:\nJust like the warning above told us, we can reduce the number of bins to 15 using the bins option in geom_histogram():\n\nggplot(penguins, aes(body_mass_g)) +\n  geom_histogram(bins = 15)\n\nWarning: Removed 2 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\n\n\n\n\n\n\n15.2.2.2 Changing the color of the bins:\nWe can change the color of the bins using the fill option in geom_histogram(). We add this to the previous options:\n\nggplot(penguins, aes(body_mass_g)) +\n  geom_histogram(bins = 15, fill = \"navy\")\n\nWarning: Removed 2 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\n\n\n\n\n\n\n15.2.2.3 Changing the axis labels:\nTo change the names of the axis labels, we add additional layers. We can change the horizontal axis label with the xlab() function, putting in quotes what we want the new label to be. Similarly, we use the ylab() function for the vertical axis label. Because these are additional layers, we add them to the plot using the + operator:\n\nggplot(penguins, aes(body_mass_g)) +\n  geom_histogram(bins = 15, fill = \"navy\") +\n  xlab(\"Penguin weight (grams)\") +\n  ylab(\"Count\")\n\nWarning: Removed 2 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\n\n\n\n\n\n\n15.2.2.4 Changing the plot theme:\nWhat if we want to get rid of the gray background? A white background is better for plots that get printed on paper. The easiest way to do this is to change the “theme” of the plot to a more minimalistic theme. We do this by adding the theme_minimal() layer:\n\nggplot(penguins, aes(body_mass_g)) +\n  geom_histogram(bins = 15, fill = \"navy\") +\n  xlab(\"Penguin weight (grams)\") +\n  ylab(\"Count\") +\n  theme_minimal()\n\nWarning: Removed 2 rows containing non-finite values (`stat_bin()`)."
  },
  {
    "objectID": "plotting-with-ggplot.html#bar-plots",
    "href": "plotting-with-ggplot.html#bar-plots",
    "title": "15  Data Visualization with ggplot",
    "section": "15.3 Bar Plots",
    "text": "15.3 Bar Plots\nWe can create a bar plot in a very similar way. We just use the categorical variable in place of the numeric one and use geom_bar() as the additional layers instead:\n\nggplot(penguins, aes(species)) +\n  geom_bar()\n\n\n\n\n\n\n\n\nWe can also get a bar plot of the number of species on each island, which displays even more information:\n\nggplot(penguins, aes(species, fill = island)) +\n  geom_bar()\n\n\n\n\n\n\n\n\nHere we can see that the Adelie is found on all 3 islands, but the Chinstrap is only on “Dream” island and the Gentoo is only on “Torgersen” island.\nWe can add layers of customization to this in a similar way. This time we will add all of the customization in one go. Here is one way to do it:\n\nggplot(penguins, aes(species, fill = island)) +\n  geom_bar(color = \"black\") +\n  xlab(\"Penguin species\") +\n  ylab(\"Count\") +\n  scale_fill_discrete(name = \"Island\",\n                      type = c(\"#0B0405\", \"#357BA2\", \"#DEF5E5\")) +\n  theme_minimal()\n\n\n\n\n\n\n\n\nThe color option in geom_bar() is for the outline of the bars (fill is for the fill color on the inside).\nWe can customize the colors and the legend name using the layer scale_fill_discrete(). This is the name of the function because this legend is for the “fill” variable, which is “discrete” because it’s a factor (as opposed to a numerical variable which would be continuous). We provide the legend name with the name option and we provide the colors using the type option. Here I’ve provided the colors using the hexidecimal format as opposed to their names like we did earlier with “navy”. This format allows you to choose exactly what shade you like. You can find the hex code for any color with many tools online. Google even has one built in if you search for “color picker”. I have chosen these colors because the differences would still be clear even if you printed out the plot in black and white."
  },
  {
    "objectID": "plotting-with-ggplot.html#scatter-plots",
    "href": "plotting-with-ggplot.html#scatter-plots",
    "title": "15  Data Visualization with ggplot",
    "section": "15.4 Scatter Plots",
    "text": "15.4 Scatter Plots\nFor scatter plots we need to provide both the x variable and the y variable in the aes() command. Let’s plot the bill length against the flipper length like we did with base R:\n\nggplot(penguins, aes(bill_length_mm, flipper_length_mm)) +\n  geom_point()\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\nIf we want to have the colors of the dots to change with the species, we can specify that with color in aes() as well:\n\nggplot(penguins, aes(bill_length_mm, flipper_length_mm, color = species)) +\n  geom_point()\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\nWe can then add some more customization in the same way as before:\n\nggplot(penguins, aes(bill_length_mm, flipper_length_mm, color = species)) +\n  geom_point() +\n  scale_color_discrete(name = \"Species\") +\n  xlab(\"Bill length (in mm)\") +\n  ylab(\"Flipper length (in mm)\") +\n  theme_minimal()\n\nWarning: Removed 2 rows containing missing values (`geom_point()`)."
  },
  {
    "objectID": "plotting-with-ggplot.html#saving-plots",
    "href": "plotting-with-ggplot.html#saving-plots",
    "title": "15  Data Visualization with ggplot",
    "section": "15.5 Saving Plots",
    "text": "15.5 Saving Plots\nThere are many different ways to save plots created by R, but a simple way to do so is to use the ggsave() function. If we want to save a plot as a PDF file we simply use the command after our ggplot() call giving the name we want to give to the plot with the file extension. For example:\n\nggplot(penguins, aes(bill_length_mm, flipper_length_mm)) +\n  geom_point()\nggsave(\"my-plot.pdf\")\n\nThe plot is saved in the current working directory - the folder given by the getwd() command."
  },
  {
    "objectID": "making-functions.html#creating-simple-functions",
    "href": "making-functions.html#creating-simple-functions",
    "title": "16  Making Functions",
    "section": "16.1 Creating Simple Functions",
    "text": "16.1 Creating Simple Functions\nIt is very easy to make your own customized functions in R. Suppose, for example, you want to make an R function to calculate the output of the quadratic function:\n\nf(x) = -8 -2x +x^2\n If we want to call this function f(), we would define it as follows:\n\nf &lt;- function(x) {\n  y &lt;- -8 - 2 * x + x^2\n  return(y)\n}\n\nThe f is what we want to call the function. We assign to f using the assignment operator, &lt;-, the “function” with a single argument x using function(x). After that we specify what the function is supposed to do:\n\nCalculate y &lt;- -8 - 2 * x + x^2\nReturn y as the output. We use the return() function to specify what the output of the function is.\n\nWe need to wrap what the function does in curly brackets ({ }) because what the function does can span several lines. Using the curly brackets tells R that these commands below together in the function.\nLet’s try out the function:\n\nf(2)\n\n[1] -8\n\nf(3)\n\n[1] -5\n\n\nWe can also pass a vector into the function to see the output for several values at once:\n\nf(c(2, 3, 4))\n\n[1] -8 -5  0"
  },
  {
    "objectID": "making-functions.html#plotting-functions",
    "href": "making-functions.html#plotting-functions",
    "title": "16  Making Functions",
    "section": "16.2 Plotting Functions",
    "text": "16.2 Plotting Functions\nWe can also use ggplot() to plot the function. To do this we first create a sequence of values of x where we want to evaluate the function. We then evaluate the function for each of these values of x and save it as y. We then combine x and y into a data.frame and plot it like we learned in Chapter 14.\nLet’s give it a try:\n\nlibrary(ggplot2)\nx &lt;- seq(from = -4, to = 6, length.out = 200)\ny &lt;- f(x)\ndf &lt;- data.frame(x, y)\nggplot(df, aes(x, y)) + geom_line()\n\n\n\n\nIn this example, the sequence runs from -4 to +6. The length.out option specifies how many numbers in total there should be in the sequence between -4 and +6. 200 numbers is plenty to get a curve that looks smooth. Why did we use -4 and +6 here? This range includes minimum and gives a good idea of its shape. You can try out different ranges instead (using numbers different from -4 and +6. When making these plots the easiest thing to do is try out different numbers until the plot looks good."
  },
  {
    "objectID": "optimization.html#plotting-approach",
    "href": "optimization.html#plotting-approach",
    "title": "17  Univariate Unconstrained Optimization",
    "section": "17.1 Plotting Approach",
    "text": "17.1 Plotting Approach\nIn Chapter 16, we also learned how to plot the function with ggplot(). We can get a visual view of the extreme point:\n\nlibrary(ggplot2)\nx &lt;- seq(from = -4, to = 6, length.out = 200)\ndf &lt;- data.frame(x, y = f(x))\nggplot(df, aes(x, y)) +\n  geom_line()\n\n\n\n\nFrom the plot we can see the following that the function achieves a minimum at x=1."
  },
  {
    "objectID": "optimization.html#analytic-solution",
    "href": "optimization.html#analytic-solution",
    "title": "17  Univariate Unconstrained Optimization",
    "section": "17.2 Analytic Solution",
    "text": "17.2 Analytic Solution\nWe could have found this number analytically using calculus. Let’s do that before doing it in R. The first derivative of the function is:\n\nf^\\prime(x) = -2 + 2x\n To find the extreme point of the function we find the value of x where f^\\prime(x)=0. This happens when: \n-2 + 2x = 0\n Solving for x yields x=1. To see if this is a maximum or a minimum we check the second derivative: \nf^{\\prime\\prime}(x) = +2\n This is positive, so we know it is a minimum. A minimum at x=1 is exactly what we see in the plot."
  },
  {
    "objectID": "optimization.html#using-optimization",
    "href": "optimization.html#using-optimization",
    "title": "17  Univariate Unconstrained Optimization",
    "section": "17.3 Using Optimization",
    "text": "17.3 Using Optimization\nWe will now use R to find the extreme point using optimization. We can use the optimize() function to find the minimum of a univariate function in R. To do that we need to specify first the function we want to minimize and an interval to search over. We specify the interval as a vector with two elements, the lower bound and the upper bound. We will use a wide interval of [-100,+100]. We also need to specify if we are looking for a maximum or a minimum. We do that with the maximum option and set it to FALSE when looking for a minimum:\n\noptimize(f, interval = c(-100, 100), maximum = FALSE)\n\n$minimum\n[1] 1\n\n$objective\n[1] -9\n\n\nWe can see that we get the same result as the plot and the analytic solution. The minimum value occurs at x=1 and the value of the function is -9 at that point.\nIf you want to maximize a function instead, we need to set maximum = TRUE.\nThe optimize() function returns a named list. Suppose we assign the output of the optimize() function to f_min:\n\nf_min &lt;- optimize(f, interval = c(-100, 100), maximum = FALSE)\nclass(f_min)\n\n[1] \"list\"\n\n\nTo extract the minimum from this list we can use f_min$minimum. The $ works for extraction with named lists the same way as with dataframes. To extract the value of the function at the minimum, we can use f_min$objective:\n\nf_min$minimum\n\n[1] 1\n\nf_min$objective\n\n[1] -9"
  },
  {
    "objectID": "ifelse.html#if-else-statements",
    "href": "ifelse.html#if-else-statements",
    "title": "18  Conditional Statements",
    "section": "18.1 If-else statements",
    "text": "18.1 If-else statements\nConditional statements, or “If-else statements” are very useful and extremely common in programming. In an if-else statement, the code first checks a particular true/false condition. If the condition is true, it performs one action, and if the condition is false, it performs another action.\nA simple example of this is the absolute value function we saw in Chapter 3. Let’s define precisely what that function does:\n\n\\left|x\\right| = \\begin{cases} -x & \\text{ if } x&lt;0 \\\\ x &\\text{ otherwise} \\end{cases}\n If x&lt;0, it returns -x (so that the number becomes positive). Otherwise, it returns just x: if x was positive it stays positive, and if x is zero it stays zero.\nAlthough there already is an absolute value function in R that we saw in Chapter 3 (the abs() function), we can easily create our own function to do the same thing.\nLet’s call this function my_abs() (my absolute value function):\n\nmy_abs &lt;- function(x) {\n  if (x &lt; 0) {\n    return(-x)\n  } else {\n    return(x)\n  }\n}\n\nAfter if, we need to write the condition to check in parentheses (here x &lt; 0). Then we write between the curly brackets ({ and }) what we want R to do if the condition is TRUE (here return -x). Then we write else and write between the curly brackets what we want R to do if the condition is FALSE (here return x).\nLet’s go through what R does here given an input x. First R checks the condition x &lt; 0. If it is TRUE it returns -x and it’s done. If it is FALSE it goes to the else and returns x.\nLet’s test it out:\n\nmy_abs(-2)\n\n[1] 2\n\nmy_abs(3)\n\n[1] 3\n\nmy_abs(0)\n\n[1] 0"
  },
  {
    "objectID": "ifelse.html#the-ifelse-function",
    "href": "ifelse.html#the-ifelse-function",
    "title": "18  Conditional Statements",
    "section": "18.2 The ifelse() function",
    "text": "18.2 The ifelse() function\nThe my_abs() function we wrote above only works with scalar inputs (vectors of length one). If we try use it with a vector it will return an error. A useful function in R is the ifelse() function, which can do if-else statements on vectors. The function takes 3 arguments:\n\nA logical vector (such as a condition to check).\nWhat to do when TRUE.\nWhat to do when FALSE.\n\nLet’s use the ifelse() function to get the absolute value of the sequence (-3, -2, -1, 0, 1, 2, 3):\n\nx &lt;- -3:3\nifelse(x &lt; 0, -x, x)\n\n[1] 3 2 1 0 1 2 3\n\n\nThe first argument checks the condition x &lt; 0. This will be TRUE for the first 3 elements, and FALSE everywhere else. Let’s see this:\n\nx &lt; 0\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n\n\nThe second argument is what to do when the condition is TRUE. This is to turn the x to -x, which makes the negative values positive. We can see that it did precisely this for the first 3 elements.\nThe third argument is what to do when the condition is FALSE. By writing just x, we are telling R to leave those elements unchanged.\nWe can also use the ifelse() statement to create other types of variables. For example, we can use it to make character variables:\n\nx &lt;- -3:3\nifelse(x &lt; 0, \"Negative\", \"Non-negative\")\n\n[1] \"Negative\"     \"Negative\"     \"Negative\"     \"Non-negative\" \"Non-negative\"\n[6] \"Non-negative\" \"Non-negative\"\n\n\nWhen x&lt;0, the output element is \"Negative\" and when x\\geq 0, the output element is \"Non-negative\"."
  },
  {
    "objectID": "ifelse.html#if-else-if-else-statements",
    "href": "ifelse.html#if-else-if-else-statements",
    "title": "18  Conditional Statements",
    "section": "18.3 “If else-if else” statements",
    "text": "18.3 “If else-if else” statements\nSometimes we want to do one thing if a certain condition holds, another thing if a different condition holds, and something else in the remaining cases. An example of this is the “sign” function, which tells you the sign in front of a value:\n\nsgn(x) = \\begin{cases}\n-1 & \\text{ if } x &lt; 0 \\\\\n0 & \\text{ if } x = 0 \\\\\n+1 & \\text{ otherwise} \\\\\n\\end{cases}\n If the value is negative, we get -1. If it’s zero we get 0. If it’s positive (the remaining case), we get +1.\nTo do this in R, we can nest several if-else statements. We simply write else if for the intermediate case:\n\nsgn &lt;- function(x) {\n  if (x &lt; 0) {\n    return(-1)\n  } else if (x == 0) {\n    return(0)\n  } else {\n    return(+1)\n  }\n}\n\nLike above, after if we write the condition to check in parentheses and in curly brackets what to do if the condition is TRUE. We then write else if and write another condition to check, as well as what to do when that condition is TRUE in curly brackets. We then write after else what to do if neither of the above conditions are TRUE.\nLet’s go through what R does here. Given an input x:\n\nR checks the condition x &lt; 0. If it is TRUE it returns -1. If it is FALSE it goes to the next step.\nR checks the condition x == 0. If it is TRUE it returns 0. If it is FALSE it goes to the next step.\nR returns +1 (happens if neither of the above conditions are TRUE).\n\nLet’s try it out:\n\nsgn(-2)\n\n[1] -1\n\nsgn(3)\n\n[1] 1\n\nsgn(0)\n\n[1] 0\n\n\n\n“If else-if else” statements with vectors\nThe above approach only works for scalars. If we want to do this with vectors, we can nest the ifelse() function inside itself like this:\n\nx &lt;- -3:3\nx\n\n[1] -3 -2 -1  0  1  2  3\n\nifelse(x &lt; 0, -1, ifelse(x == 0, 0, 1))\n\n[1] -1 -1 -1  0  1  1  1\n\n\nLet’s take apart what’s happening in ifelse(x &lt; 0, -1, ifelse(x == 0, 0, 1)) for an element in x:\n\nR first checks for each element in x if x&lt;0. If it is TRUE, it returns -1; if it is FALSE, it goes to the next ifelse().\nIf we go to the next ifelse(), it checks if the element satisfies x=0. If this is TRUE it returns 0; if it is FALSE, it returns +1."
  },
  {
    "objectID": "merging.html#data-cleaning",
    "href": "merging.html#data-cleaning",
    "title": "19  Merging",
    "section": "19.1 Data Cleaning",
    "text": "19.1 Data Cleaning\nFirst we read in and clean the petrol price data. You can download the dataset here.\n\ndf1 &lt;- read.csv(\"avg_daily_petrol_prices.csv\")\n# Format dates:\ndf1$date &lt;- as.Date(df1$date, format = \"%Y-%m-%d\")\nsummary(df1)\n\n      date                  e5             e10            diesel      \n Min.   :2014-06-08   Min.   :1.159   Min.   :1.130   Min.   :0.9558  \n 1st Qu.:2016-07-03   1st Qu.:1.340   1st Qu.:1.318   1st Qu.:1.1322  \n Median :2018-07-29   Median :1.402   Median :1.379   Median :1.2353  \n Mean   :2018-07-29   Mean   :1.456   Mean   :1.423   Mean   :1.2811  \n 3rd Qu.:2020-08-23   3rd Qu.:1.522   3rd Qu.:1.479   3rd Qu.:1.3217  \n Max.   :2022-09-18   Max.   :2.261   Max.   :2.203   Max.   :2.3343  \n\nnrow(df1)\n\n[1] 3025\n\n\nWe now do the same with the Brent crude oil prices. You can download the dataset here.\n\ndf2 &lt;- read.csv(\"Europe_Brent_Spot_Price_FOB.csv\", skip = 4)\n# Format dates:\ndf2$Day &lt;- as.Date(df2$Day, format = \"%m/%d/%Y\")\n# Rename variables:\nnames(df2) &lt;- c(\"date\", \"crude_oil\")\n# Sort ascending:\ndf2 &lt;- df2[order(df2$date), ]\nsummary(df2)\n\n      date              crude_oil     \n Min.   :1987-05-20   Min.   :  9.10  \n 1st Qu.:1996-03-06   1st Qu.: 19.03  \n Median :2005-01-04   Median : 38.08  \n Mean   :2005-01-12   Mean   : 48.22  \n 3rd Qu.:2013-11-24   3rd Qu.: 69.67  \n Max.   :2022-09-19   Max.   :143.95  \n\nnrow(df2)\n\n[1] 8970\n\n\nWe see that the petrol price data covers 2014-2022, and the crude oil price data covers 1987-2022. If we look closer at the dates, we notice that the crude oil price data doesn’t include the weekends, whereas the petrol price data does:\n\nhead(df1$date, n = 10)\n\n [1] \"2014-06-08\" \"2014-06-09\" \"2014-06-10\" \"2014-06-11\" \"2014-06-12\"\n [6] \"2014-06-13\" \"2014-06-14\" \"2014-06-15\" \"2014-06-16\" \"2014-06-17\"\n\nhead(df2$date, n = 10)\n\n [1] \"1987-05-20\" \"1987-05-21\" \"1987-05-22\" \"1987-05-25\" \"1987-05-26\"\n [6] \"1987-05-27\" \"1987-05-28\" \"1987-05-29\" \"1987-06-01\" \"1987-06-02\""
  },
  {
    "objectID": "merging.html#merging",
    "href": "merging.html#merging",
    "title": "19  Merging",
    "section": "19.2 Merging",
    "text": "19.2 Merging\n\n19.2.1 The merge() Command\nNow that the two datasets are clean, we merge the two using the merge() function. The first two arguments of the merge() function are the two datasets we want to merge. The third argument, by, species the variable name (in quotations) that link the two datasets. In our case, the variable linking the two is the date variable.\n\ndf &lt;- merge(df1, df2, by = \"date\")\nsummary(df)\n\n      date                  e5             e10            diesel      \n Min.   :2014-06-09   Min.   :1.159   Min.   :1.130   Min.   :0.9558  \n 1st Qu.:2016-07-04   1st Qu.:1.339   1st Qu.:1.318   1st Qu.:1.1302  \n Median :2018-07-26   Median :1.402   Median :1.379   Median :1.2345  \n Mean   :2018-07-27   Mean   :1.455   Mean   :1.422   Mean   :1.2797  \n 3rd Qu.:2020-08-19   3rd Qu.:1.521   3rd Qu.:1.478   3rd Qu.:1.3216  \n Max.   :2022-09-16   Max.   :2.261   Max.   :2.203   Max.   :2.3343  \n   crude_oil     \n Min.   :  9.12  \n 1st Qu.: 48.54  \n Median : 61.18  \n Mean   : 63.47  \n 3rd Qu.: 72.97  \n Max.   :133.18  \n\nnrow(df)\n\n[1] 2107\n\n\nWe notice that the dataset becomes much smaller: only 2,107 observations instead of 3,025 in df1 and 8,970 in df2. This is because df1 only contained dates from 2014 onwards, and df2 only contains data on weekdays. The merged datasets only includes weekdays between 2014-2022, and is thus much smaller.\n\n\n19.2.2 Keeping Unmatched Observations\nIf we want to avoid dropping the observations where there is no match, we can use one of the following options:\n\nall.x = TRUE : Keeps all observations in the 1st dataset, but only merges data from the 2nd dataset when there is a match. When there is no match, variables in the 2nd dataset get assigned NA values.\nall.y = TRUE : Keeps all observations in the 2nd dataset, but only merges data from the 1st dataset when there is a match. When there is no match, variables in the 1st dataset get assigned NA values.\nall = TRUE : This keeps all observations from both datasets, and variables get assigned NA values when there is no match. This is equivalent to setting both all.x = TRUE and all.y = TRUE.\n\nFor example, suppose we use the all.x = TRUE option:\n\ndf &lt;- merge(df1, df2, by = \"date\", all.x = TRUE)\nsummary(df)\n\n      date                  e5             e10            diesel      \n Min.   :2014-06-08   Min.   :1.159   Min.   :1.130   Min.   :0.9558  \n 1st Qu.:2016-07-03   1st Qu.:1.340   1st Qu.:1.318   1st Qu.:1.1322  \n Median :2018-07-29   Median :1.402   Median :1.379   Median :1.2353  \n Mean   :2018-07-29   Mean   :1.456   Mean   :1.423   Mean   :1.2811  \n 3rd Qu.:2020-08-23   3rd Qu.:1.522   3rd Qu.:1.479   3rd Qu.:1.3217  \n Max.   :2022-09-18   Max.   :2.261   Max.   :2.203   Max.   :2.3343  \n                                                                      \n   crude_oil     \n Min.   :  9.12  \n 1st Qu.: 48.54  \n Median : 61.18  \n Mean   : 63.47  \n 3rd Qu.: 72.97  \n Max.   :133.18  \n NA's   :918     \n\nnrow(df)\n\n[1] 3025\n\n\nWe see that we have 3,025 rows, the same as the original df1. However, the variable crude_oil, which was merged from df2 now has 918 missing values. Any time df2$crude_oil didn’t have a value for a date in df1, we replace it with an NA. When we didn’t specify all.x = TRUE, we ended up with 2,107 observations. This is because it dropped all the rows where there was no match. The 2,107 comes from the 3,025 original rows in df1, minus the 918 rows where there was no corresponding match in df2 (3,025-918=2,107).\n\n\n19.2.3 Other Merging Options\nFinally, we end with some further remarks on the merge() function. First, if you are merging on multiple variables, you can include a vector of variable names in the by argument. For example, suppose you are merging the two datasets:\n\ndf1: contains the revenue in each market area (variable market_area) and date (variable date).\ndf2: contains the advertising expenditure in each market area (variable market_area) and date (variable date).\n\nLet’s create two example datasets for illustration purposes here:\n\ndf1 &lt;- data.frame(expand.grid(\n  market_area = c(\"Market A\", \"Market B\"),\n  date = seq(as.Date(\"2022-01-01\"), as.Date(\"2022-03-01\"), by = \"month\")\n))\ndf1$revenue &lt;- runif(n = nrow(df1), min = 0, max = 1000)\n\ndf2 &lt;- data.frame(expand.grid(\n  market_area = c(\"Market A\", \"Market B\"),\n  date = seq.Date(as.Date(\"2022-01-01\"), as.Date(\"2022-03-01\"), by = \"month\")\n))\ndf2$advertising_exp &lt;- runif(n = nrow(df1), min = 0, max = 500)\n\ndf1\n\n  market_area       date   revenue\n1    Market A 2022-01-01 485.76845\n2    Market B 2022-01-01 940.01892\n3    Market A 2022-02-01  74.59912\n4    Market B 2022-02-01 785.79297\n5    Market A 2022-03-01 109.54504\n6    Market B 2022-03-01 961.13105\n\ndf2\n\n  market_area       date advertising_exp\n1    Market A 2022-01-01        480.6382\n2    Market B 2022-01-01        426.6870\n3    Market A 2022-02-01        236.2161\n4    Market B 2022-02-01        302.1044\n5    Market A 2022-03-01        415.5219\n6    Market B 2022-03-01        212.2895\n\n\nSome notes on the functions used here:\n\nThe expand.grid() function here creates every combination of each market area and date (you won’t be asked to use this function in the exam).\nThe seq() function can also be used to create sequences of dates. We can specify the step length to be \"day\" \"month\", \"quarter\" or \"year\".\nThe runif() function creates n random numbers between min and max (you won’t be asked to use this function in the exam).\n\nWe can merge these two datasets by simply including a vector of the variable names in the by argument:\n\ndf &lt;- merge(df1, df2, by = c(\"market_area\", \"date\"))\ndf\n\n  market_area       date   revenue advertising_exp\n1    Market A 2022-01-01 485.76845        480.6382\n2    Market A 2022-02-01  74.59912        236.2161\n3    Market A 2022-03-01 109.54504        415.5219\n4    Market B 2022-01-01 940.01892        426.6870\n5    Market B 2022-02-01 785.79297        302.1044\n6    Market B 2022-03-01 961.13105        212.2895\n\n\nIf the variable names are different in the two datasets, we could change the names of the variables to make them match before merging. But what we could do instead is use the by.x and by.y options in the merge() function. For instance, suppose in the previous example the market area variable was called \"market\" in df2 instead of \"market_area\". Let’s change the name of the variable in df2 to that:\n\nnames(df2)[names(df2) == \"market_area\"] &lt;- \"market\"\n\nIf I want to merge the two datasets in this case I can do:\n\ndf &lt;- merge(df1, df2, by.x = c(\"market_area\", \"date\"),\n            by.y = c(\"market\", \"date\"))\ndf\n\n  market_area       date   revenue advertising_exp\n1    Market A 2022-01-01 485.76845        480.6382\n2    Market A 2022-02-01  74.59912        236.2161\n3    Market A 2022-03-01 109.54504        415.5219\n4    Market B 2022-01-01 940.01892        426.6870\n5    Market B 2022-02-01 785.79297        302.1044\n6    Market B 2022-03-01 961.13105        212.2895\n\n\nFinally, by default, merge() will sort the data by the merging variable(s). To avoid this behaviour you can use the sort = FALSE option."
  },
  {
    "objectID": "reshaping.html#from-long-to-wide",
    "href": "reshaping.html#from-long-to-wide",
    "title": "20  Reshaping",
    "section": "20.1 From Long to Wide",
    "text": "20.1 From Long to Wide\nSuppose we have the following dataset:\n\nlong &lt;- data.frame(\n  id       = rep(1:3, each = 2),\n  variable = rep(c(\"x\", \"y\"), times = 3),\n  value    = c(3, 5, 4, 8, 3, 1)\n)\nlong\n\n  id variable value\n1  1        x     3\n2  1        y     5\n3  2        x     4\n4  2        y     8\n5  3        x     3\n6  3        y     1\n\n\nThis dataset is in what is called “long” format. We have 3 individuals, with IDs 1, 2, 3. For each individual we have 2 variables, x and y, and for each individual and variable we observe the value in in the value column.\nIf we want to reshape this data so that it has only 1 row per individual (3 rows in total), with the variables x and y as separate variables, we can use functions from the reshape2 package. Install the package with install.packages(\"reshape2\"). You can use the dcast() function from this package to reshape the data as follows:\n\nlibrary(reshape2)\nwide &lt;- dcast(long, id ~ variable)\nwide\n\n  id x y\n1  1 3 5\n2  2 4 8\n3  3 3 1\n\n\nThe first argument is the name of the dataset. The second argument is the formula for how to reshape. We put the ID variable that we want to represent the rows first, then we use the ~ symbol, and then we put the variable with the different variable names."
  },
  {
    "objectID": "reshaping.html#from-wide-to-long",
    "href": "reshaping.html#from-wide-to-long",
    "title": "20  Reshaping",
    "section": "20.2 From Wide to Long",
    "text": "20.2 From Wide to Long\nWe can also go the other direction. Let’s get back to our original data by reshaping the new wide data back to long. Let’s call the output long2. We can do that with the melt() function:\n\nlong2 &lt;- melt(wide, id.vars = \"id\")\nlong2\n\n  id variable value\n1  1        x     3\n2  2        x     4\n3  3        x     3\n4  1        y     5\n5  2        y     8\n6  3        y     1\n\n\nAgain, the first argument is the name of the dataset. The second is the variable is the varying representing the observation IDs."
  },
  {
    "objectID": "reshaping.html#example-usage-case",
    "href": "reshaping.html#example-usage-case",
    "title": "20  Reshaping",
    "section": "20.3 Example Usage Case",
    "text": "20.3 Example Usage Case\nSometimes with ggplot, we need to have the data in long format. This happens when we want to plot multiple variables on the same plot with different colors. Let’s use the petrol price dataset from Chapter 19 to demonstrate this:\n\n# Read in and clean petrol price data:\ndf &lt;- read.csv(\"avg_daily_petrol_prices.csv\")\ndf$date &lt;- as.Date(df$date)  # format dates\nhead(df)\n\n        date       e5      e10   diesel\n1 2014-06-08 1.551987 1.477774 1.353583\n2 2014-06-09 1.576623 1.483362 1.385182\n3 2014-06-10 1.569619 1.478455 1.374060\n4 2014-06-11 1.572578 1.481119 1.377091\n5 2014-06-12 1.574652 1.480383 1.378247\n6 2014-06-13 1.584659 1.492049 1.387577\n\n\nThe dataset is currently in “wide” format. The date runs down the dataset and the variables (petrol prices) at each date are stored horizontally from this. Let’s go to “long” format with the melt() function, where \"date\" represents the observation IDs.\n\ndf2 &lt;- melt(df, \"date\")\nhead(df2)\n\n        date variable    value\n1 2014-06-08       e5 1.551987\n2 2014-06-09       e5 1.576623\n3 2014-06-10       e5 1.569619\n4 2014-06-11       e5 1.572578\n5 2014-06-12       e5 1.574652\n6 2014-06-13       e5 1.584659\n\n\nNow the dataset is in long format: we have the date, a variable representing the variable names (variable), and the values of each variable (value).\nLet’s use this long-format data to plot the petrol prices over time for each type of petrol:\n\nlibrary(ggplot2)\nggplot(df2, aes(date, value, color = variable)) +\n  geom_line()\n\n\n\n\nWe can customize this plot a bit with:\n\nlevels(df2$variable) &lt;- c(\"E5\", \"E10\", \"Diesel\")\nggplot(df2, aes(date, value, color = variable)) +\n  geom_line() +\n  xlab(\"\") +\n  ylab(\"Average Daily Petrol Price (in Euro)\") +\n  scale_color_discrete(name = \"Petrol Type:\") +\n  theme_minimal() +\n  theme(legend.direction = \"horizontal\",\n        legend.position = \"bottom\")"
  },
  {
    "objectID": "aggregating.html",
    "href": "aggregating.html",
    "title": "21  Aggregating by Group",
    "section": "",
    "text": "Sometimes we want to get the average or sum of a variable by group. We can do this in R using the aggregate() function. Let’s learn this function using an example. We will use the daily average petrol price data from before. Suppose we wanted to get the average petrol price by year from this. Let’s load up the data again:\n\ndf &lt;- read.csv(\"avg_daily_petrol_prices.csv\")\ndf$date &lt;- as.Date(df$date)  # format dates\n\nTo aggregate by year, we first need to create a variable which gives the year corresponding to the date. There are several ways to do this.\nOne way to get the year is to re-format the date so that it only shows the year. Recall from Chapter 13, that %Y represents the year in R:\n\ndf$year &lt;- format(df$date, format = \"%Y\")\n\n\n\n\n\nBut an easier way is to use the year() function from the lubridate package. You can install it with install.packages(\"lubridate\"). With this package loaded, we can use the function with:\n\nlibrary(lubridate)\ndf$year &lt;- year(df$date)\n\nThe next step is to use the aggregate() function. If I want the average price of E10 petrol by year, I can do the following:\n\naggregate(e10 ~ year, FUN = mean, data = df)\n\n  year      e10\n1 2014 1.461632\n2 2015 1.373425\n3 2016 1.282375\n4 2017 1.345430\n5 2018 1.430955\n6 2019 1.408177\n7 2020 1.253603\n8 2021 1.522833\n9 2022 1.875897\n\n\nHere we first provide the formula: We want the average of e10 by year so we write e10 ~ year. The function we want to use is the mean (to get the average). Finally, we provide the name of the dataset, df.\nWe can calculate the average of all petrol prices by year by adding all the variables with cbind():\n\naggregate(cbind(e5, e10, diesel) ~ year, FUN = mean, data = df)\n\n  year       e5      e10   diesel\n1 2014 1.519195 1.461632 1.334612\n2 2015 1.393170 1.373425 1.173013\n3 2016 1.302767 1.282375 1.081282\n4 2017 1.368414 1.345430 1.161306\n5 2018 1.454098 1.430955 1.287264\n6 2019 1.430592 1.408177 1.265341\n7 2020 1.288080 1.253603 1.111068\n8 2021 1.579992 1.522833 1.387114\n9 2022 1.933512 1.875897 1.941386\n\n\nIf you have a lot of variables, you can get the average of all of them by year by replacing the part before the ~ with a dot:\n\naggregate(. ~ year, FUN = mean, data = df)\n\n  year    date       e5      e10   diesel\n1 2014 16332.0 1.519195 1.461632 1.334612\n2 2015 16618.0 1.393170 1.373425 1.173013\n3 2016 16983.5 1.302767 1.282375 1.081282\n4 2017 17349.0 1.368414 1.345430 1.161306\n5 2018 17714.0 1.454098 1.430955 1.287264\n6 2019 18079.0 1.430592 1.408177 1.265341\n7 2020 18444.5 1.288080 1.253603 1.111068\n8 2021 18810.0 1.579992 1.522833 1.387114\n9 2022 19123.0 1.933512 1.875897 1.941386\n\n\nYou may notice that this also gives us the average of the date variable in the year as numbers that don’t look like dates. Similar to Excel, underlying each date in R is a number which is the number of days since the 1/1/1970 (in Excel it’s days since 1/1/1900). 1/1/2014 is 16,071 days since 1/1/1970, so that is why we see numbers this size there.\nWe can also replace mean with any function we like. For example, to get the maximum average daily price in a year:\n\naggregate(e10 ~ year, FUN = max, data = df)\n\n  year      e10\n1 2014 1.542430\n2 2015 1.499718\n3 2016 1.375595\n4 2017 1.393057\n5 2018 1.552005\n6 2019 1.533291\n7 2020 1.438141\n8 2021 1.703694\n9 2022 2.203362\n\n\nTo get the number of observations per year:\n\naggregate(e10 ~ year, FUN = length, data = df)\n\n  year e10\n1 2014 207\n2 2015 365\n3 2016 366\n4 2017 365\n5 2018 365\n6 2019 365\n7 2020 366\n8 2021 365\n9 2022 261"
  },
  {
    "objectID": "tutorials.html",
    "href": "tutorials.html",
    "title": "Tutorial Exercises",
    "section": "",
    "text": "Below are links to the exercises and solutions for each of the tutorial exercises.\n\nWeek 2: Chapters 2-8\n\nExercises\nSolutions\n\n\n\nWeek 3: Chapters 9-12\n\nExercises\nSolutions\n\n\n\nWeek 4: Chapter 13\n\nExercises\nSolutions\n\n\n\nWeek 5: Chapters 14-15\n\nExercises\nSolutions\n\n\n\nWeek 6: Chapters 16-18\n\nExercises\nSolutions\n\n\n\nWeek 7: Chapters 19-21\n\nExercises\nSolutions"
  }
]